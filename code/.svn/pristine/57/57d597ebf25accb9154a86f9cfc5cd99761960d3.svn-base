# -*- coding: utf-8 -*-
"""
Annotation Tool: For annotating path time series over human tracking video
Copyright: Alex Leykin @ CIL
Email: cil@indiana.edu
http://indiana.edu/~cil
Software bindings: 
"""

# Import modules
import os,sys
from random import randint, shuffle
from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from label import *
from path import *
from polygon import *
from rectangle import *
from ellipse import *
from commands import *
from snapshot import *
from variabledialog import *

class AnnotateScene(QGraphicsScene):
    loadSignal  = pyqtSignal(QGraphicsItem)
    saveSignal  = pyqtSignal(QGraphicsItem)
    loadVideoSignal  = pyqtSignal(QString)    
    initCategoriesSignal  = pyqtSignal()    
    updateVideoSignal = pyqtSignal(QGraphicsItem)      
    addItemListSignal = pyqtSignal(QGraphicsItem)          
    removeItemListSignal = pyqtSignal(QGraphicsItem)          
    updateItemListSignal = pyqtSignal(QGraphicsItem)              
    changeCurrentItemSignal = pyqtSignal()        
    modes = ('Select', 'Path', 'Separator', 'Edit', 'Polygon',  'Rectangle',  'Label', 'Snapshot')    
    gridD = 1
    
    currentPath = None        
    currentPolygon = None    
    backgroundPath = ''
    pathSmoothingFactor = 0.5
    variables = {}
    font = QFont('Verdana', 2.2)    
    #    add dialog to change K to project properties
    
    time = QTime()
    
    def __init__(self):
        QGraphicsScene.__init__(self)
        # Undo stack
        self.undoStack = QUndoStack(self)      
        self.setSceneRect(0,  0,  320.0, 180.0)
        self.clear()
        
    def clear(self):
        QGraphicsScene.clear(self)
        self.heatmap = QGraphicsPixmapItem()
        self.background = QGraphicsPixmapItem()
        self.addItem(self.heatmap)
        self.addItem(self.background)
        self.heatmap.setZValue(-1)
        self.background.setZValue(-2)        
        self.heatmap.setVisible(False) 
        self.filename = None
        self.currentPath = None
        self.currentPolygon = None              
        self.backgroundPath = ''  
        self.s = None      # current stacking item index
        self.variables.clear()
        
    def removeItem(self,  item):
        if type(item) == Path:
            self.removeItemListSignal.emit(item)
            self.currentPath = None
        QGraphicsScene.removeItem(self, item)

    def addItem(self,  item):
        QGraphicsScene.addItem(self, item)
        if type(item) == Path:
            self.addItemListSignal.emit(item)
            self.currentPath = item
    
    def updateProjectProperties(self):
        self.removeItem(self.background)
        self.background = QGraphicsPixmapItem()
        self.addItem(self.background)        
        if self.backgroundPath != '' and self.backgroundPath != None:
            pixmap = QPixmap(os.path.join(os.path.dirname(str(self.filename)), self.backgroundPath))
            self.background.setPixmap(pixmap)
            self.background.scale((self.width()+1)/pixmap.width(),  (self.height()+1)/pixmap.height())
            self.background.setZValue(-2)        

        # update paths
        for item in self.items():
             if type(item) == Path:
                path = QPainterPath()
                item.addQuadFromPolygon(path, item.polygon)
                item.setPath(path)

# TODO: import Tobii eye-tracking data 

# TODO: import survey data
    def loadData(self, filename):
        import csv
        reader = csv.reader(open(filename, 'rb'))
        ids = next(reader,  None)
        for line in reader:
            print reader.line_num
            if not QString(line[0]) in self.variables: # skip non-existing variables
                continue     
#            row = self.table.rowCount()
#            self.table.insertRow(row)            
#            for i, col in enumerate(line):
#                item = QTableWidgetItem()
#                item.setData(Qt.DisplayRole, col)
#                self.table.setItem(row,  i,  item)           


    def load(self, s, buildNumber, merge = False):
        # read scene properties
        w = s.readFloat()
        h = s.readFloat()
        self.setSceneRect(0,  0,  w, h)
        # read categories Path and Backgound Image Path
        if (buildNumber < 41):
            for i, name in enumerate(permanentVariableNames):
                cols = QVariant([param for param in permanentVariableParams[i]])
                self.variables[QString(name)] = cols        
            self.categoriesPath = s.readString()       

        self.backgroundPath = s.readString()
        # read project variables
        if (buildNumber >= 41):
            self.variables = s.readQVariantMap() 
        if (buildNumber >= 41 and buildNumber < 42):
            for name in self.variables:
                l = self.variables[name].toList()
                l.insert(0, QVariant(''))
                self.variables[name] = QVariant(l)

        # read items
        nItems = s.readInt()
        for i in range(nItems):
            cItem = s.readQString()
            item = eval(str(cItem)+'()') # create an item instance of appropriate type
            if type(item) == QGraphicsPixmapItem:
                continue                      
            item.read(s, buildNumber)
            if merge:
                if type(item) == Path:
                    self.addItem(item)            
            else:
                self.addItem(item)    
        self.updateProjectProperties()

    def save(self, s):
        # write scene properties
        s.writeFloat(self.width())
        s.writeFloat(self.height())
        # write categories Path and Backgound Image Path
        s.writeString(self.backgroundPath)
        # write project variables
        s.writeQVariantMap(self.variables)
        # write items
        s.writeInt(len(self.items())-2) # minus the heatmap and the background image
        for i in self.items():
            # skip heatmap
            if type(i) == QGraphicsPixmapItem:
                continue            
            s.writeQString(i.__class__.__name__)
            i.write(s)
            
    def mousePressEvent(self, event):
#        print 'mouse press in AnnotationView'
        # cycle through stacking order if more than 1 item under mouse
        items = self.items(event.scenePos())        
        if event.modifiers() == Qt.NoModifier and len(items) > 1: 
            if not self.s: self.s = items[0]       
            else:
                try:
                    N = items.index(self.s)
                except ValueError:
                    N = 0
                self.s = items[(N+1) % len(items)]
                self.s.stackBefore(items[N])
          
        if (event.buttons() & Qt.LeftButton):
            sp = event.scenePos()
            # copy item with alt+Drag
            if self.mode == 'Edit' and (event.modifiers() & Qt.AltModifier):
                for i in self.scene.selectedItems():
                    item = eval('i.clone()')
                    self.undoStack.push(AddCommand(self.scene, item))                                             
            elif self.mode == 'Path':                
                # Add new path
                if (not self.currentPath or event.modifiers() & Qt.ShiftModifier):
                    self.currentPath = Path(sp,  self.font, 1.0)
                    self.undoStack.push(AddCommand(self, self.currentPath))                                             
                else:
                    self.currentPath.handleMousePress(event)
            elif self.mode == 'Polygon':           
                if (not self.currentPolygon or event.modifiers() & Qt.ShiftModifier):   
                    self.undoStack.push(AddCommand(self, Polygon(sp,  self.font, 0.4)))                                                             
                else:
                    self.currentPolygon.addPoint(sp)  
            elif self.mode == 'Rectangle':             
                self.undoStack.push(AddCommand(self, Rectangle(sp,  self.font, 0.4)))                                             
            elif self.mode == 'Ellipse':                
                self.undoStack.push(AddCommand(self, Ellipse(sp,  self.font, 0.4))) 
            elif self.mode == 'Label':                
                self.undoStack.push(AddCommand(self, Label(sp,  self.font, 0.4)))                 
            elif self.mode == 'Snapshot':                
                self.undoStack.push(AddCommand(self, Snapshot(sp,  self.font, 0.4)))                                 
        elif (event.buttons() & Qt.RightButton):
            if self.mode == 'Path' and self.currentPath:                
                self.currentPath.handleMousePress(event)
        QGraphicsScene.mousePressEvent(self,  event)     
        
class AnnotateView(QGraphicsView):
    
    def __init__(self, parent):
        QGraphicsView.__init__(self,  parent)
        self.scene= AnnotateScene()
        self.setScene(self.scene)
#        self.scene.setSceneRect(0, 0, 320, 180)
        Z = 1.0
        self.FONT_ZOOM_FACTOR = 1.1
        self.scale(Z, Z)
        self.scene.mode = self.scene.modes[0]
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.scene.filename = ''
        zoomInFontKey = QAction(self)
        zoomInFontKey.setShortcut(QKeySequence('Ctrl+='))
        zoomInFontKey.triggered.connect(self.zoomInFontPressed)                 
        self.addAction(zoomInFontKey)
        zoomOutFontKey = QAction(self)
        zoomOutFontKey.setShortcut(QKeySequence('Ctrl+-'))
        zoomOutFontKey.triggered.connect(self.zoomOutFontPressed)                 
        self.addAction(zoomOutFontKey)
        startTimeKey = QAction(self)
        startTimeKey.setShortcut(Qt.Key_F1)        
        startTimeKey.triggered.connect(self.startTimeKeyPressed)           
        self.addAction(startTimeKey)        
        stopTimeKey = QAction(self)
        stopTimeKey.setShortcut(Qt.Key_F2)        
        stopTimeKey.triggered.connect(self.stopTimeKeyPressed)           
        self.addAction(stopTimeKey)
        qApp.installEventFilter(self)              
        
    def zoomInFontPressed(self):
        for i in self.scene.selectedItems():
            f = i.font.toPyObject() 
            f.setPointSizeF(f.pointSizeF()*self.FONT_ZOOM_FACTOR)
            i.font = QVariant(f)
            self.scene.loadSignal.emit(i)
        self.scene.update()    

    def zoomOutFontPressed(self):
        for i in self.scene.selectedItems():
            f = i.font.toPyObject() 
            f.setPointSizeF(f.pointSizeF()/self.FONT_ZOOM_FACTOR)
            i.font = QVariant(f)
            self.scene.loadSignal.emit(i)
        self.scene.update()    

    def startTimeKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.startTime[self.scene.currentPath.indP] = QVariant(self.scene.time)
            self.scene.loadSignal.emit(self.scene.currentPath)
            
    def stopTimeKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP  != None:
            self.scene.currentPath.stopTime[self.scene.currentPath.indP] = QVariant(self.scene.time)
            self.scene.loadSignal.emit(self.scene.currentPath)

    
    def eventFilter(self, object, event):
        if (event.type() == QEvent.KeyPress):
            for name in self.scene.variables:
                vDescr, vType, vShow, vShortcut,  vEachNode, vGroup, vChoices = self.scene.variables[name].toList()
                shortcut = vShortcut.toString()
                if shortcut == keyEventToKeySequence(event).toString():
                    # toggle corresponding variable
                    item = self.scene.currentPath                    
                    varType = vType.toString()
                    if vEachNode.toBool(): # list                    
                        if item.indP == None: continue
                        li = item.variables[name].toList()
                        if varType == 'Yes/No':                        
                            li[item.indP] = QVariant(not li[item.indP].toBool())
                        elif varType == 'Integer':                        
                            li[item.indP] = QVariant(li[item.indP].toInt()[0]+1)
                        item.variables[name] = QVariant(li)
                    else:
                        if varType == 'Yes/No':                        
                            item.variables[name] = not item.variables[name]
                        elif varType == 'Integer':                                
                            li[item.indP] = QVariant(li[item.indP].toInt()[0]+1)
                    self.scene.loadSignal.emit(item)
                    return True            
        return QGraphicsView.eventFilter(self,  object, event)
            
#Size scene to fit the view
    def fitSceneInView(self):
        self.setTransform(QTransform())
        s = min(self.width()/self.scene.width(), self.height()/self.scene.height())
        self.scale(s, s);
        
    def wheelEvent(self, event):
        factor = 1.2
        if event.delta() < 0:
            factor = 1.0 / factor
        self.scale(factor, factor)

    def drawBackground (self, painter,  r):
        QGraphicsView.drawBackground(self,  painter,  r)
        painter.setPen(QColor("black"))
        painter.setOpacity(0.1)
        r = self.sceneRect()
        x = r.left()
        while x <= r.right():
            painter.drawLine(x, r.top(), x, r.bottom())     
            x += self.scene.gridD
        y = r.top()            
        while y <= r.bottom():
            painter.drawLine(r.left(), y, r.right(), y)     
            y += self.scene.gridD          
