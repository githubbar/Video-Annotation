# -*- coding: utf-8 -*-
""" PrepertyTree View/Model is a widget for editing object's properties stored in a dictionary attribute *data* """
from PyQt4.QtGui import *
from PyQt4.QtCore import *
import sys
from label import *
from path import *
from polygon import *
from rectangle import *
from ellipse import *
from delegates import *

CheckBoxType = QStandardItem.UserType+1
# TODO: implement grouping of items
class PropertyTreeView(QTreeView,  object):
    def __init__(self,parent,task=None):
        QTreeView.__init__(self,parent)
        self.setModel(PropertyTreeModel())     
        self.setAlternatingRowColors(True)     
        self.currentItem = None
        
    def dataChanged(self,  topLeft,  bottomRight):
        QTreeView.dataChanged(self,  topLeft,  bottomRight)
        if self.currentItem:

            self.saveItem(self.currentItem)
            self.currentItem.update()
            
    def loadItem(self, item):
        self.currentItem = item
        self.model().removeRows(0,  self.model().rowCount())
        """Load selected item properties"""
        self.delegates = []
        for k in item.shownFields:
            v = getattr(item, k)
            col1 = PropertyTreeItem(k)
            col1.setFlags(col1.flags()  & ~Qt.ItemIsEditable)            
            # if list, get current element
            if type(v) == list:
                if item.indP == None: continue
                v = v[item.indP]

            col2 = PropertyTreeItem(v)                
            col2.setEditable(True)
            col2.setData(QColor("#0000FF"), Qt.TextColorRole)
            if k in item.checkableFields:
                col2.setCheckable(True)
                if v.toBool(): col2.setData(Qt.Checked,  Qt.CheckStateRole)
                col2.setData('',  Qt.DisplayRole)
                col2.setEditable(False)

            self.model().appendRow([col1,  col2])     
            row = self.model().rowCount()-1                
            # custom delegates
            if k == 'startTime' or k == 'stopTime':
                self.delegates.append(TimeDelegate())
                self.setItemDelegateForRow(row,  self.delegates[-1])               
            if k == 'tripType':
                self.delegates.append(DropDownDelegate(item.scene().tripTypeChoices, v))
                self.setItemDelegateForRow(row,  self.delegates[-1])   
            if k == 'category':
                self.delegates.append(DropDownDelegate(item.scene().categoryChoices,  v))
                self.setItemDelegateForRow(row,  self.delegates[-1])                   
            if k == 'videoname' or k == 'imagename':
                sceneDir = os.path.dirname(str(self.currentItem.scene().filename))
                self.delegates.append(FileOpenDelegate(sceneDir))
                self.setItemDelegateForRow(row,  self.delegates[-1])                                   
            # font delegate
            if k == 'font':
                self.delegates.append(FontOpenDelegate())
                self.setItemDelegateForRow(row,  self.delegates[-1])       
                
        #### Begin display dymanic project variables 
        if type(item) != Path: 
            return
        for name in item.scene().variables:
            params = item.scene().variables[name].toList()
            #'Type', 'Show?', 'Keyboard Shortcut', 'Apply to Each Node?', 'Group'
            if params[1].toBool():
                col1 = PropertyTreeItem(name)
                col1.setFlags(col1.flags()  & ~Qt.ItemIsEditable)            
                if params[3].toBool(): # list
                    if item.indP == None: continue
                    col2 = PropertyTreeItem(item.variables[name].toList()[item.indP])                
                else:
                    col2 = PropertyTreeItem(item.variables[name])               
                col2.setEditable(True)
                col2.setData(QColor("#0000FF"), Qt.TextColorRole)
                self.model().appendRow([col1,  col2])     
                row = self.model().rowCount()-1
                if params[0] == 'Yes/No':
                    self.delegates.append(CheckBoxDelegate(row, 1))
                    self.setItemDelegateForRow(row,  self.delegates[-1])                   
                elif params[0] == 'Double':
                    self.delegates.append(DoubleDelegate(row, 1))
                    self.setItemDelegateForRow(row,  self.delegates[-1])                                   
                elif params[0] == 'Integer':
                    self.delegates.append(IntegerDelegate(row, 1))
                    self.setItemDelegateForRow(row,  self.delegates[-1])                                                       
           #### End display dymanic project variables 

    def saveItem(self, item):
        """Save item properties: passing a PropertyTreeView properties"""
        print 'saving item',  item
        for row in range(self.model().rowCount()):
            name = self.model().item(row,  0).data(Qt.EditRole).toPyObject()
            if name in item.scene().variables:  # temp
                #### Begin Save dymanic project variables             
                params = item.scene().variables[name].toList()
                if params[3].toBool(): # list
                    if item.indP == None: continue
                    li = item.variables[name].toList()
                    li[item.indP] = self.model().item(row,  1).data(Qt.EditRole)
                    item.variables[name] = QVariant(li)
                else:
                    item.variables[name] = self.model().item(row,  1).data(Qt.EditRole)
                #### End Save dymanic project variables 
            else:
                if name in item.checkableFields:
                    if self.model().item(row,  1).checkState() == Qt.Checked:
                        value = QVariant(True)
                    else:
                        value = QVariant(False)
                else:
                    value = self.model().item(row,  1).data(Qt.EditRole)
                # load video if selected for the first time
    #            if name == 'videoname' and self.currentItem.videoname.toString()=='':
    #                self.currentItem.scene().loadVideoSignal.emit(value.toString())

                # if list: write to list element
                l = getattr(item, str(name))
                if type(l) == list:
                    if item.indP == None:
                        continue
                    else:
                        l[item.indP] = value
                        value = l
                setattr(item, str(name), value)

        if type(item) == Path:
            item.scene().updateItemListSignal.emit(item)

class PropertyTreeItem(QStandardItem):
    def __init__(self, data=None):
        QStandardItem.__init__(self)
        self.setData(data,  Qt.EditRole)

class PropertyTreeModel(QStandardItemModel):
    def __init__(self, parent=None):
        QStandardItemModel.__init__(self,  parent)
        self.setColumnCount (2)
        self.setHeaderData(0,  Qt.Horizontal,  'Property')
        self.setHeaderData(1,  Qt.Horizontal,  'Value')

