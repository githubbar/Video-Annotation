# -*- coding: utf-8 -*-
""" Path Item"""

from PyQt4.QtGui import *
from PyQt4.QtCore import *
import os, datetime, threading, subprocess, time, sys, csv

from settings import *
from propertywidget import *
from delegates import *
from commands import *

class Path(QGraphicsPathItem):
    id, videoname, tripType = QVariant(), QVariant(), QVariant()
    description, tags, startTime, stopTime,  purchased, shopped,  phone,  employee,  category  = [], [], [], [], [], [], [], [], []
    shownFields = ['id', 'videoname', 'tripType','description', 'tags', 'startTime', 'stopTime',  'category', 'purchased', 'shopped',  'phone', 'employee']
    checkableFields  = ['purchased', 'shopped',  'phone', 'employee']
    tripTypeChoices = ['fill in', 'routine', 'stock up', 'occasion']     
    categoryChoices = []     
    indP = None # current node index
    R = 1.0 # node radius 
    K= 6.0 # orientation line length compared to R    
    penR = 0.3 # edge width
    
    def __init__(self, font=QFont('White Rabbit',  2),  opacity=1.0):    
        QGraphicsPathItem.__init__(self)
        self.stroker = QPainterPathStroker()        
        self.stroker.setWidth(1*self.R)        
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsFocusable | QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemClipsToShape)
#        | QGraphicsItem.ItemClipsToShape
        self.videoname = QVariant(QString(''))
        self.setBrush(QColor(Qt.transparent))
        self.setPen(QPen(QBrush(Qt.blue), self.penR))
        self.setCursor(Qt.ArrowCursor)
        self.polygon = QPolygonF()     
        self.orientation = QPolygonF()     
        self.setOpacity(opacity)
        self.font = QVariant(font)
        self.choosingOrientation = False
        self.categoryChoices = self.readCategoriesFromFile('categories.txt')
        self.categoryChoices.sort()
        
    def readCategoriesFromFile(self,  fileName):
        import csv
        reader = csv.reader(open(fileName, 'rb'))
        for row in reader:
            return row
            
    def shape(self):
        sh = self.stroker.createStroke(self.path())
        for i in range(self.polygon.count()):
            sh.addEllipse(self.polygon[i],  self.K,  self.K)
        return sh
        
    def clone(self):    
        other = Path(self.videoname, self.font,  self.opacity())
        other.indP = self.indP
        other.id, other.videoname, other.tripType, other.description, other.tags, other.time, other.endTime, other.purchased, \
        other.shopped,  other.phone,  other.employee,  other.category = \
        self.id, self.videoname, self.tripType, list(self.description), list(self.tags), list(self.startTime), list(self.stopTime),  list(self.purchased), \
        list(other.shopped),  list(other.phone),  list(other.employee),  list(other.category)
        
        other.polygon = QPolygonF(self.polygon)
        other.orientaiton= QPolygonF(self.orientaiton)
        path = QPainterPath()
        path.addPolygon(self.polygon)
        other.setPath(path)        
        return other

    def write(self, s):
#        for i in range(len(self.description)):
#            if self.tags[i].toString() == '':
#                self.tags[i] = self.description[i]
#                self.description[i] = QVariant('')
#            i += 1
#        self.videoname = QVariant(os.path.join('videos',os.path.split(str(self.videoname.toString()))[1]))        
        s.writeQVariant(self.id)
        s.writeQVariant(self.videoname)        
        s.writeQVariant(self.tripType)        
        s.writeQVariantList(self.description)
        s.writeQVariantList(self.tags)
        s.writeQVariantList(self.startTime)        
        s.writeQVariantList(self.stopTime)        
        s.writeQVariantList(self.purchased)
        s.writeQVariantList(self.shopped)                
        s.writeQVariantList(self.category)
        s.writeQVariantList(self.phone)
        s.writeQVariantList(self.employee)        
        
        s << self.polygon        
        s << self.orientation
        s.writeFloat(self.opacity())
        s << self.font
        
    def read(self, s):
        self.id = s.readQVariant()
        self.videoname =  s.readQVariant()
        self.tripType =  s.readQVariant()
        self.description = s.readQVariantList()
        self.tags = s.readQVariantList()
        self.startTime = s.readQVariantList()
        self.stopTime = s.readQVariantList()
#Begin TEMP
#        for i in range(len(self.startTime)):
#            self.startTime[i] = QVariant(QTime().addMSecs(self.startTime[i].toInt()[0]))
#            self.stopTime[i] = QVariant(QTime().addMSecs(self.stopTime[i].toInt()[0]))
#End TEMP
        self.purchased = s.readQVariantList()        
        self.shopped = s.readQVariantList()        
        self.category=  s.readQVariantList()         
        self.phone = s.readQVariantList()        
        self.employee = s.readQVariantList()        
#Begin TEMP
#        self.category = list(QVariant() for r in range(len(self.purchased)))
#        self.phone = list(QVariant() for r in range(len(self.purchased)))
#        self.employee = list(QVariant() for r in range(len(self.purchased)))
#End TEMP
        s >> self.polygon
        s >> self.orientation
        self.setOpacity(s.readFloat())
#        f = QFont()
#        s >> f
#        self.font = QVariant(f)           
        s >> self.font             
        path = QPainterPath()
        path.addPolygon(self.polygon)    
        self.setPath(path)
        
    def boundingRect(self):
        r = super(Path,  self).boundingRect()
        return r.adjusted(-self.K*self.R,  -self.K*self.R,  self.K*self.R,  self.K*self.R)
        
    def paint(self, painter, option, widget):
        QGraphicsPathItem.paint(self, painter, option, widget)

        painter.setPen(Qt.red)      
        painter.setFont(self.font.toPyObject())
        for i in range(self.polygon.count()):
            if self.purchased[i].toBool():
                painter.setBrush(QBrush(Qt.green))
            elif self.shopped[i].toBool():
                painter.setBrush(QBrush(Qt.blue))                
            else:
                painter.setBrush(QBrush(Qt.transparent))                                
            painter.drawEllipse(self.polygon.at(i), self.R, self.R) 
            line = QLineF(self.polygon.at(i),  self.orientation.at(i))
            line.setLength(self.K*self.R)
            painter.drawLine(line) 
    
    
    def updatePoint(self, i, p):
        if i == None:
            return        
        self.polygon.replace(i,  p)
        path = QPainterPath()
        path.addPolygon(self.polygon)
        self.setPath(path)
    
    def updatePointCommand(self, i, p):
        if i == None:
            return        
        self.scene().undoStack.push(UpdatePointCommand(self,  i, p))
        
    def updateOrientation(self, i, p):
        if i == None:
            return        
        self.orientation.replace(i,  p)

    def updateOrientationCommand(self, i, p):
        if i == None:
            return        
        self.scene().undoStack.push(UpdateOrientationCommand(self,  i, p))            

    def deletePoint(self):
        if self.indP == None or self.indP == 0 and len(self.polygon) == 1:
            self.scene().undoStack.push(RemoveCommand(self.scene(), self))                            
        else:
            self.scene().undoStack.push(RemovePointCommand(self,  self.indP, self.polygon[self.indP]))                                             
    
        
    def addPoint(self, p, time):
        self.scene().undoStack.push(AddPointCommand(self,  len(self.polygon), p, time))                                             
        
    def insertPoint(self, i, p):
        if len(self.polygon) < 2 or i >= len(self.polygon)-1: 
            return
        self.scene().undoStack.push(AddPointCommand(self,  i+1, p))                                             


        
    def getNearestPoint(self, p):
        mini=0
        mind = sys.maxint
        for i in range(self.polygon.count()):
            dist = (self.polygon.at(i)-p).manhattanLength()
            if  dist < mind:
                mind = dist
                mini = i
        return mini

    def getNearestLineSegment(self, p):
        if self.polygon.count() < 2:
            return 0
        i1 = 0
        d1 = sys.maxint
        for i in range(self.polygon.count()-1):
            l = QLineF(self.polygon.at(i), self.polygon.at(i+1))
            n = l.normalVector()
            n.translate(p-n.p2())
            ip = QPointF() 
            res = l.intersect(n, ip)
            n = QLineF(ip, p)
            res = l.intersect(n, ip)
            if res == QLineF.UnboundedIntersection:
                dist = min([(p-l.p1()).manhattanLength(), (p-l.p2()).manhattanLength()])
            elif res == QLineF.BoundedIntersection:
                dist = (p-ip).manhattanLength()
            else:
                continue
            if dist < d1:
                d1 = dist
                i1 = i
        return i1
        
    def focusInEvent (self, event):
        QGraphicsItem.focusInEvent (self, event)
        self.scene().loadSignal.emit(self)     
        self.scene().currentPath = self
        self.scene().changeCurrentItemSignal.emit()

    def focusOutEvent (self, event):
        QGraphicsItem.focusOutEvent(self, event)
        if self.polygon.count():
            self.scene().saveSignal.emit(self)
            
    def mousePressEvent(self, event):
#        print 'mouse press over path ' + self.id.toString()
        if (event.buttons() & Qt.LeftButton): self.handleLeftMousePress(event.pos(),  event.modifiers())
        elif (event.buttons() & Qt.RightButton): self.handleRightMousePress(event.pos(),  event.modifiers())

    def handleMousePress(self, sp, modifiers, time=QTime()):
       # get new point closest to mouse and load it
        if self.scene().mode == 'Select' or self.scene().mode == 'Path':
            self.indP = self.getNearestPoint(sp)
            if (sp-self.polygon.at(self.indP)).manhattanLength() > self.scene().gridD:
                self.indP = None        
            self.scene().updateVideoSignal.emit(self)                
#            self.scene().currentPath = self
#            self.setSelected(True)
            
    def handleLeftMousePress(self, sp, modifiers, time=QTime()):
        self.handleMousePress(sp, modifiers, time)        
        if self.scene().mode == 'Path':
            if not self.choosingOrientation:
                # save old point
                if (modifiers & Qt.ControlModifier):
                    # add new point between two closest points
                    i = self.getNearestLineSegment(sp)
                    self.insertPoint(i, sp)
                if self.indP != None:
                    self.updatePointCommand(self.indP, sp)
                else:
                    self.addPoint(sp, time)

    def handleRightMousePress(self, sp, modifiers, time=0):
        self.handleMousePress(sp, modifiers,  time)
        if self.scene().mode == 'Path':
            self.choosingOrientation = True
                    
    def itemChange(self, change, value):
        if (change == QGraphicsItem.ItemSelectedHasChanged):
            if self.isSelected():
                self.setPen(QPen(QBrush(QColor(255, 165, 0)), self.penR*1.5))    
#                unselect all other items in the scene
                for i in self.scene().selectedItems():
                    if i != self:
                        i.setSelected(False)
            else: 
                self.setPen(QPen(QBrush(Qt.blue), self.penR))      
        return QGraphicsItem.itemChange(self, change, value)
        
    def mouseReleaseEvent(self, event):                
            # TODO: choosing orientation undo !!!
#            self.updateOrientationCommand(self.indP, sp)
        self.scene().loadSignal.emit(self)            
        self.choosingOrientation = False

    def mouseMoveEvent(self, event):
        if self.scene().mode == 'Path' and self.indP != None:
            if self.choosingOrientation:
                self.updateOrientation(self.indP, event.pos())
                self.update()
            else:
                self.updatePoint(self.indP, event.pos())
        
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete:
            self.deletePoint()
            

    def toString(self):
        return self.id
