from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from heatmap import HeatMap        
import os, csv, threading, logging

class SearchWidget:
    matches = []
    def readCategoriesFromFile(self,  fileName):
        self.category.clearContents()
        self.category.setRowCount(0)        
        reader = csv.reader(open(fileName, 'rb'))
        row = reader.next()
        for i,  item in enumerate(row):
            self.category.insertRow(i)
            self.category.setItem(i, 0,  QTableWidgetItem(item))        
        self.category.sortItems(0)

    def searchClicked(self):
        # clear results
        self.matches = []            
        self.results.clearContents()
        self.results.setRowCount(0)        
        self.guiMode(self.GUI_SEARCH)                  
        threading.Thread(target=self.doSearch, name="doSearch").start()
        
    def doSearch(self):
        # scan all items
        for i in range(self.items.rowCount()):
            item = self.items.item(i, 0).g
            match = False
            self.emit(SIGNAL("updateProgress"), int(100.0*i/self.items.rowCount()) )
            # scan all nodes
            for n in range(len(item.polygon)):            
                # ---------------- filter by category
                cat = item.category[n]
                if len(self.category.selectedItems()) == 0: 
                    categoryMatch = True
                else:
                    categoryMatch = False
                    for c in self.category.selectedItems():
                        if cat.toString() == c.data(Qt.EditRole).toString():
                            categoryMatch = True
                            break
                # ---------------- filter by start and stop time
                t1 = item.startTime[n].toTime()
                t2 = item.stopTime[n].toTime()
        
                if not self.timeCheckBox.isChecked(): 
                    timeMatch = True
                elif t1 > self.startTimeFilter.time() and t2 < self.stopTimeFilter.time():
                    timeMatch = True
                else:
                    timeMatch = False
                    
                # combine search criteria
                match = categoryMatch and timeMatch
                if match: self.matches.append(Match(item, n))
                if not self.go: break                
        self.emit(SIGNAL("completeProgress"), self.GUI_NORMAL)

       
    def refreshResults(self):
        for i,  match in enumerate(self.matches):
            self.results.insertRow(i)
            self.results.setItem(i, 0,  QTableWidgetItem(match.item.id.toString()))    
            self.results.setItem(i, 1,  QTableWidgetItem(match.item.startTime[match.n].toTime().toString('hh:mm:ss')))    

    def visClicked(self):
        self.guiMode(self.GUI_EXPORT)                  
        paletteFile='palettes/classic.png'
        W = int(self.graphicsView.scene.width())
        H = int(self.graphicsView.scene.height())
        heatmapBox=[0,  W,  0,  H]
        hm = HeatMap(heatmapBox[0], heatmapBox[1], heatmapBox[2],  heatmapBox[3],  paletteFile)
        # add data points        
        hp = []
        for i,  match in enumerate(self.matches):
            self.progressBar.setValue(int(100.0*i/len(self.matches)))         
            self.searchWidget.repaint()          
            if not self.go: 
                hp = []
                break                
            n = match.n
            addThis = True
            if self.visPurchased.isChecked(): addThis &= match.item.purchased[n].toBool()
            if self.visShopped.isChecked(): addThis &= match.item.shopped[n].toBool()
            if not addThis: continue
            # create as many points as there are seconds
            if self.visUseTime.isChecked():
                count = match.item.startTime[n].toTime().secsTo(match.item.stopTime[n].toTime())
            else: count = 1
            for c in range(count):
                hp += [(match.item.polygon.at(n).x(), match.item.polygon.at(n).y())]

        hm.add_points(hp, self.visRadius.value()) 
        hm.transform_color(0.05*self.visAlpha.value())
        p = QPixmap.fromImage(QImage(hm.get_image_buffer(), hm.width,  hm.height,  QImage.Format_ARGB32))
        self.graphicsView.scene.heatmap.setPixmap(p)
        self.graphicsView.scene.heatmap.setVisible(True)          
        self.guiMode(self.GUI_NORMAL)          
        
    def exportVideoClicked(self):
        # choose export folder
        outDir = QFileDialog.getExistingDirectory(self, "Choose Folder to Export To", os.getcwdu())
        if not outDir:
            return        
        self.guiMode(self.GUI_EXPORT)                  
        threading.Thread(target=self.doExportVideo, name="exportVideoThread",  args=(outDir, )).start()
        
    def doExportVideo(self, outDir):
        import subprocess, re        
 
        for i,  match in enumerate(self.matches):
#            print str(int(100.0*i/len(self.matches)))            
            self.emit(SIGNAL("updateProgress"), int(100.0*i/len(self.matches)))
            
            inFileName = os.path.join(os.path.dirname(str(self.graphicsView.scene.filename)), str(match.item.videoname.toString()))
  
            t1 = match.item.startTime[match.n].toTime()
            t2 = match.item.stopTime[match.n].toTime()
           
            cat = match.item.category[match.n].toString()
            cat = cat.replace('/', '-')
            cat = cat.replace(':', '-')
            outFileName = os.path.join(str(outDir), str(match.item.id.toString()+' from '+t1.toString('hh-mm-ss')+' to '+t2.toString('hh-mm-ss')+' ' \
            +cat+'.avi'))
            if os.path.exists(inFileName):
                logging.debug('Current working directory is '+str(os.getcwd()))              
                p = subprocess.Popen(['ffmpeg', '-ss', str(QTime().secsTo(t1)), '-t',  str(t1.secsTo(t2)), '-i', str(inFileName), \
                '-async',  '1', '-y',  str(outFileName)],  shell=True)
                p.wait()
                logging.debug('ffmpeg'+ ' -ss '+ str(QTime().secsTo(t1))+ ' -t ' +  str(t1.secsTo(t2)) + ' -i ' + str(inFileName)+ ' -y '+  str(outFileName))
            if not self.go: break
        self.emit(SIGNAL("completeProgress"), self.GUI_NORMAL)
       
    def exportDataClicked(self):
        self.guiMode(self.GUI_EXPORT)
        # choose export file
        outFileName = QFileDialog.getSaveFileName(self, "Choose File to Export To", os.getcwdu())
        if not outFileName:
            return        
        writer = csv.writer(open(outFileName, 'wb'))            
        writer.writerow(['id', 'node number', 'startTime', 'stopTime',  'category', 'tripType', 'purchased', 'shopped',  'phone', 'employee'])
        for i,  match in enumerate(self.matches):
            self.progressBar.setValue(int(100.0*i/len(self.matches)))         
            print str(int(100.0*i/len(self.matches)))            
            self.searchWidget.repaint()          
            writer.writerow([str(match.item.id.toString()), str(match.n), \
              str(match.item.startTime[match.n].toTime().toString('hh-mm-ss')),  \
              str(match.item.stopTime[match.n].toTime().toString('hh-mm-ss')),  \
              str(match.item.tripType.toString()),  \
              str(match.item.purchased[match.n].toString()),  \
              str(match.item.shopped[match.n].toString()),  \
              str(match.item.phone[match.n].toString()),  \
              str(match.item.employee[match.n].toString()) \
                              ])
            if not self.go: break
        self.guiMode(self.GUI_NORMAL)  

    def cancelClicked(self):
        self.go = False
        
    def updateProgress(self,  now):
        self.progressBar.setValue(now)
        self.searchWidget.repaint()     
        
    def guiMode(self,  searchMode=None):
        if searchMode == self.GUI_NORMAL or searchMode == None:
            self.go = False
            self.searchCancel.hide()                     
            self.exportCancel.hide()                  
            self.progressBar.reset()
            self.progressBar.hide() 
            self.searchButton.setEnabled(True) 
            self.exportData.setEnabled(True) 
            self.exportVideo.setEnabled(True)       
            self.refreshResults()
            
        elif searchMode == self.GUI_EXPORT:
            self.go = True
            self.exportCancel.show()            
            self.progressBar.reset()
            self.progressBar.show() 
            self.searchButton.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.exportData.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.progressBar.setValue(0)     
            self.searchWidget.repaint() 
        elif searchMode == self.GUI_SEARCH:
            self.go = True
            self.progressBar.setValue(100)         
            self.searchCancel.show()            
            self.progressBar.reset()
            self.progressBar.show() 
            self.searchButton.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.exportData.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.progressBar.setValue(0)     
            self.searchWidget.repaint() 
        
class Match:
    def __init__(self, item,  n):
        self.item = item
        self.n = n
