# -*- coding: utf-8 -*-
"""
Annotation Tool: For annotating path time series over human tracking video
Copyright: Alex Leykin @ CIL
Email: cil@indiana.edu
http://indiana.edu/~cil
Software bindings: 
    
Developed with: 
    Python 2.7 x32bit (http://www.python.org/download/releases/2.7.1/)
    Python modules: 
        PyQt: http://www.riverbankcomputing.co.uk/software/pyqt/download    
        PyWin32: http://sourceforge.net/projects/pywin32/ (windows extensions, need it for system uptime)
        
    Eric4 python IDE (http://eric-ide.python-projects.org/eric-download.html)
    Cx-freeze: http://cx-freeze.sourceforge.net/ (to make executables)
    
====================================================================================

SVN commits go to: https://bl-bus-leykin10.ads.iu.edu:8443/svn/VA2/
"""

#import sys
#sys.path.insert( 0, '.' )
#import OpenGL.platform.win32
#import OpenGL.arrays.ctypesarrays
#import OpenGL.arrays.ctypesparameters
#import OpenGL.arrays.ctypespointers
#import OpenGL.arrays.lists
#import OpenGL.arrays.nones
#import OpenGL.arrays.numbers
#import OpenGL.arrays.strings
#import OpenGL.platform.win32
#import OpenGL.raw.GL
#import dummy.Process
#import email.Generator
#import email.Iterators
#import OpenGL.GL
#import OpenGL.GLU
#import OpenGL.GLUT
#from OpenGL.GL import *
#from OpenGL.GLUT import *
#from OpenGL.GLU import *
import OpenGL.arrays.formathandler

# Import modules
import logging
logging.basicConfig(filename='debug.log',level=logging.DEBUG) 
logging.basicConfig(filename='warning.log',level=logging.WARNING) 
logging.basicConfig(filename='error.log',level=logging.ERROR) 

import os, sys
from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from annotateview import *
from pathtablewidget import *
from commands import *
import vlc
import menu, buttonevents, searchwidget, help
# Create a class for our main window
class Main(QMainWindow,  Ui_MainWindow, buttonevents.ButtonEvents,  searchwidget.SearchWidget):
    GUI_NORMAL = 0
    GUI_SEARCH = 1
    GUI_EXPORT = 2
    BUILD_NUMBER = 40
    go = False   # search/export thread is not running
    def __init__(self):
        QMainWindow.__init__(self)
        Ui_MainWindow.__init__(self)
        self.setupUi(self)
        
        self.help = None
        
        # TEMP
        qApp.installEventFilter(self)
        # END TEMP
        
        # Menu
        menu.createMenu(self)

        # Toolbar
        self.toolbar = QToolBar(self)
        self.actions = []
        for i, text in enumerate(self.graphicsView.scene.modes):
            action = QAction(QIcon('icons/'+text+'.png'), text, self)
            if text != 'Separator':
                action.setShortcut('Ctrl+'+str(i+1))
                action.setCheckable(True)
                self.actions.append(action)
                action.triggered.connect(self.handleToolbarButton)
            else:
                action.setSeparator(True)
            self.toolbar.addAction(action)
        self.actions[0].setChecked(True)
#        self.addToolBar(Qt.TopToolBarArea,  self.toolbar)
        self.toolbar.setOrientation(Qt.Vertical)
        self.gridLayout.addWidget(self.toolbar,  0, 0, -1, 1)

        # Video View
        self.Instance = vlc.Instance('--fullscreen')
        self.mediaPlayer = self.Instance.media_player_new()
        self.isPaused = True
        self.playButton.setIcon(QIcon('icons/player_play.png'))
        self.timer = QTimer(self)
        self.timer.setInterval(200)
        
        self.fullScreen = False
        toggleFullscreen = QAction(self)
        toggleFullscreen.setShortcut(Qt.Key_F11)        
        toggleFullscreen.triggered.connect(self.handleFullScreen)    
        self.addAction(toggleFullscreen)       
        setRate = QAction(self)
        setRate.setShortcut(QKeySequence('CTRL+R'))        
        setRate.triggered.connect(self.setPlaybackRate)    
        self.addAction(setRate)     
        
        rew = QAction(self)
        rew.setShortcut(Qt.Key_Left)        
        rew.triggered.connect(self.rew)    
        self.addAction(rew)   
        ff = QAction(self)
        ff.setShortcut(Qt.Key_Right)        
        ff.triggered.connect(self.ff)    
        self.addAction(ff)     
        rew5 = QAction(self)
        rew5.setShortcut(QKeySequence('CTRL+Left'))        
        rew5.triggered.connect(self.rew5)    
        self.addAction(rew5)   
        ff5 = QAction(self)
        ff5.setShortcut(QKeySequence('CTRL+Right'))        
        ff5.triggered.connect(self.ff5)    
        self.addAction(ff5)           
        
        # Edit tab
        self.graphicsView.scene.loadSignal.connect(self.propertyView.loadItem)  
        self.graphicsView.scene.saveSignal.connect(self.propertyView.saveItem)          
        self.graphicsView.scene.loadVideoSignal.connect(self.loadVideo)          
        self.graphicsView.scene.updateVideoSignal.connect(self.updateVideo)    
        self.graphicsView.scene.initCategoriesSignal.connect(self.initCategories)    
        self.graphicsView.scene.addItemListSignal.connect(self.items.addItem)  
        self.graphicsView.scene.removeItemListSignal.connect(self.items.removeItem)  
        self.graphicsView.scene.updateItemListSignal.connect(self.items.updateItem)  
        self.graphicsView.scene.changeCurrentItemSignal.connect(self.changeCurrentItem)  
        self.items.itemClicked.connect(self.checkItem)
        self.items.currentItemChanged.connect(self.currentItemChanged)
        self.items.deleteKeyPressed.connect(self.deleteItem)
        self.checkAll.clicked.connect(self.toggleAllItems)
        self.seekSlider.sliderMoved.connect(self.setPosition)
        self.playButton.clicked.connect(self.playClicked)
        self.timer.timeout.connect(self.updateUI)
        self.connect( self.tabWidget, SIGNAL("currentChanged(int)"), self.tabChanged)
        
        
        # Search tab
        self.searchButton.clicked.connect(self.searchClicked)
        self.exportVideo.clicked.connect(self.exportVideoClicked)
        self.exportData.clicked.connect(self.exportDataClicked)
        self.searchCancel.clicked.connect(self.cancelClicked)        
        self.exportCancel.clicked.connect(self.cancelClicked)
        self.connect( self, SIGNAL("updateProgress"), self.updateProgress)       
        self.connect( self, SIGNAL("completeProgress"), self.guiMode)       
        self.guiMode(self.GUI_NORMAL)
        self.tabChanged(self.tabWidget.currentIndex())

        # Visualize tab
        self.visButton.clicked.connect(self.visClicked)
    def setPlaybackRate(self):
        rate, ok= QInputDialog.getDouble(self, 'Input Dialog', 'Enter playback rate:', 1.0,  0.1, 100)        
        if ok: 
            self.mediaPlayer.set_rate(rate)

    def rew(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() - 1000)            
        self.updateUI()

    def ff(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() + 1000)            
        self.updateUI()
        
    def rew5(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() - 5000)            
        self.updateUI()

    def ff5(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() + 5000)            
        self.updateUI()        


#    def eventFilter(self, object, event):
#        if (event.type() == QEvent.MouseButtonPress):
#            print "The bad guy which steals the MousePress is"
#            print object
#        return False
        
    def loadVideo(self, filename):
        """Open a media file in a mediaPlayer"""
        if filename=='':
            filename = QFileDialog.getOpenFileName(self, "Open File", os.getcwdu())
        filename = os.path.join(os.path.dirname(str(self.graphicsView.scene.filename)), str(filename))
        filename =  'file:///'+filename   
        self.Media = self.Instance.media_new(unicode(filename))
        self.mediaPlayer.set_media(self.Media)
        self.Media.parse()
#        self.setWindowTitle(self.Media.get_meta(0))
        if sys.platform == "linux2": # for Linux using the X Server
            self.mediaPlayer.set_xwindow(self.videoPlayer.winId())
        elif sys.platform == "win32": # for Windows
            self.mediaPlayer.set_hwnd(self.videoPlayer.winId())
        elif sys.platform == "darwin": # for MacOS
            self.mediaPlayer.set_agl(self.videoPlayer.windId())

    def fileOpen(self):
        self.clear()
#        filename = QFileDialog.getOpenFileName(self, "Open File", os.getcwdu())
#        filename  = 'd:/Projects/Video Annotation/POPAI San Jose 2012-01-06-20-01-720007/data'
        filename  = 'd:/Projects/Visual Attention/Project TW Mobile/Data/Stop n Shop - Wyckoff/Annotation/data'
        if not filename:
            return
        self.fileNew()
        self.graphicsView.scene.filename = filename
        file = QFile(self.graphicsView.scene.filename)
        file.open(QIODevice.ReadOnly)
        s = QDataStream(file)
        buildNumber = s.readInt()        
        if (self.BUILD_NUMBER != buildNumber):
            QMessageBox.warning(self,  "Warning!",  "The data file is in format for build " + str(buildNumber) + ' \nCurrent software build is '+str(self.BUILD_NUMBER))
#            return
        self.graphicsView.scene.load(s,  buildNumber)
        self.actions[0].trigger()
        self.graphicsView.scene.update()

    def clear(self):
        self.graphicsView.scene.undoStack.clear()
        self.graphicsView.scene.clear()
        self.items.clearContents()
        self.items.setRowCount(0)
        self.actions[0].trigger()
        
    def fileNew(self):
        self.clear()
        self.graphicsView.scene.update()
        

    def fileMerge(self):
        filename = QFileDialog.getOpenFileName(self, "Open File to Merge", os.getcwdu())
        if not filename:
            return
        if not self.graphicsView.scene.filename:
           self.graphicsView.scene.filename = filename
        file = QFile(filename)
        file.open(QIODevice.ReadOnly)
        s = QDataStream(file)
        buildNumber = s.readInt()        
        if (self.BUILD_NUMBER != buildNumber):
            QMessageBox.warning(self,  "Warning!",  "The data file is in format for build " + str(buildNumber) + ' \nCurrent software build is '+str(self.BUILD_NUMBER))
        self.graphicsView.scene.load(s, buildNumber, True)            
        self.graphicsView.scene.update()
        
    def fileSave(self):
        import shutil, datetime
        if not self.graphicsView.scene.filename: # run "save as" if no file name
            filename = QFileDialog.getSaveFileName(self, "Save File As", os.getcwdu())
            if not filename:
                return     
            self.graphicsView.scene.filename = filename                
        elif os.path.exists(self.graphicsView.scene.filename): # create a backup
            path,  name = os.path.split(unicode(self.graphicsView.scene.filename))
            shutil.move(self.graphicsView.scene.filename, os.path.join(path, datetime.datetime.today().strftime("%Y%m%d%H%M%S")+'.backup') )  
        file = QFile(self.graphicsView.scene.filename)
        file.open(QIODevice.WriteOnly)
        s = QDataStream(file)
        s.writeInt(self.BUILD_NUMBER)
        self.graphicsView.scene.save(s)
            
    def fileSaveAs(self):
        filename = QFileDialog.getSaveFileName(self, "Save File As", os.getcwdu())
        if not filename:
            return     
        self.graphicsView.scene.filename = filename                
        self.fileSave()
            

    def stop(self):
        """Stop player"""
        self.mediaPlayer.stop()
        self.playButton.setIcon(QIcon('icons/player_play.png'))
        
    def setPosition(self, Position):
        """Set the position"""
        self.mediaPlayer.set_position(Position / 1000.0)

    def updateVideo(self, item):
        """Set the position based on the time on Path node"""
        if item.indP == None or item.startTime[item.indP] == None: 
            return
        time = QTime().msecsTo(item.startTime[item.indP].toTime())
        self.mediaPlayer.set_time(time)
        self.updateUI()
        
    def updateUI(self):
        """updates the user interface"""
        self.seekSlider.setValue(self.mediaPlayer.get_position() * 1000)
        if not self.mediaPlayer.is_playing():
            self.timer.stop()
            if not self.isPaused:
                self.stop()
        
        time = self.mediaPlayer.get_time()
        if time != -1:
            self.graphicsView.scene.time = QTime().addMSecs(time)
            if self.graphicsView.scene.currentPath:
#                self.graphicsView.scene.currentPath.time = self.graphicsView.scene.time
                self.graphicsView.scene.currentPath.update()
            self.status.setText(self.graphicsView.scene.time.toString('hh:mm:ss'))
        else:
            self.status.setText(QTime().toString('hh:mm:ss'))
            
    def deleteItem(self):
        if self.items.currentItem():
            self.graphicsView.scene.undoStack.push(RemoveCommand(self.graphicsView.scene, self.items.currentItem().g))                                        
                
                
    def checkItem(self, item):
        if item.checkState() == Qt.Checked:
            item.g.setVisible(True)
        else:
            item.g.setVisible(False)

    def changeCurrentItem(self):        
        #  choose current item
        for n in range(self.items.rowCount()):
            i = self.items.item(n, 0)
            if self.graphicsView.scene.currentPath == i.g:
                self.items.setCurrentItem(i)
                i.g.setVisible(True)
                i.setCheckState(Qt.Checked)
                
    def currentItemChanged(self, current, previous):
        self.graphicsView.scene.clearSelection()
        if current:
            current.g.setSelected(True)
            self.graphicsView.scene.currentPath = current.g
            self.graphicsView.scene.loadSignal.emit(self.graphicsView.scene.currentPath)            
            if current.g.videoname.toString() != '': self.loadVideo(current.g.videoname.toString())               
            self.timer.start()
        
    def toggleAllItems(self):
        nItems = self.items.rowCount()
        if nItems == 0:
            return
        if self.items.item(0, 0).checkState() == Qt.Unchecked:
            self.checkAllItems(True)
        else: 
            self.checkAllItems(False)
            
    def checkAllItems(self, check=True):
        nItems = self.items.rowCount()
        for n in range(nItems):
            self.items.item(n, 0).setCheckState(Qt.Checked if check else Qt.Unchecked)
            self.items.item(n, 0).g.setVisible(check)
                
    def showUndoHistory(self):
        self.undoView.show()
        self.undoView.adjustSize()
        self.undoView.setAttribute(Qt.WA_QuitOnClose, False)
       
    def about(self):
        import datetime
        QMessageBox.about(self,  'About',  \
            '<p>Copyright \xa9 2013 <a href="http://indiana.edu/~cil">Customer Interface Lab</a>, <a href="http://iub.edu">Indiana University.</a> All Rights Reserved.'+\
            '<p>Redistribution and use of this software for commercial purposes is strictly prohibited.'+\
            '<p>THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES,\
        INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\
        FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS,\
        COPYRIGHT HOLDERS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\
        INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\
        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\
        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\
        OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'+\
            '<p><p>Email: <a href="mailto:cil@indiana.edu">cil@indiana.edu</a>'+\
            '<p>Build number: '+str(self.BUILD_NUMBER)+\
            '<p>Build date: '+ datetime.datetime.today().strftime("%Y-%m-%d %H:%M"))
            
    def initHelp(self):
        from PyQt4 import QtHelp
        from PyQt4.QtWebKit import QWebView
        import helpbrowser
        self.help = QtHelp.QHelpEngine('help/help.qhc',  self)
        ok = self.help.setupData()

        self.helpWindow = QDialog(self, Qt.Window)            
        self.helpWindow.setWindowTitle('Video Annotation Help')
        helpBrowser = helpbrowser.HelpBrowser(self.help)
        helpPanel = QSplitter(Qt.Vertical)
        helpPanel.addWidget(self.help.contentWidget() )
        helpPanel.addWidget(helpBrowser)
        helpPanel.setStretchFactor(1, 4)
        self.helpWindow.setLayout(QVBoxLayout())
        self.helpWindow.layout().addWidget(helpPanel)
        self.helpWindow.setMinimumSize(640, 700)
        self.help.contentWidget().linkActivated.connect(helpBrowser.load)
        
def main():
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    sys.exit(app.exec_())
  
if __name__ == "__main__":
    main()
    










    





