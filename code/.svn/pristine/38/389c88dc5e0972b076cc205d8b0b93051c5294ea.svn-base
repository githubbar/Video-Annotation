# -*- coding: utf-8 -*-
""" PrepertyTree View/Model is a widget for editing object's properties stored in a dictionary attribute *data* """
from PyQt4.QtGui import *
from PyQt4.QtCore import *
import sys
from label import *
from path import *
from polygon import *
from rectangle import *
from ellipse import *
from delegates import *

CheckBoxType = QStandardItem.UserType+1
# TODO: implement grouping of items
class PropertyTreeView(QTreeView,  object):
    def __init__(self,parent,task=None):
        QTreeView.__init__(self,parent)
        self.setModel(PropertyTreeModel())     
        self.setAlternatingRowColors(True)     
        self.currentItem = None
        
    def dataChanged(self,  topLeft,  bottomRight):
        QTreeView.dataChanged(self,  topLeft,  bottomRight)
        if self.currentItem:

            self.saveItem(self.currentItem)
            self.currentItem.update()
            
    def loadItem(self, item):
        import operator
        self.currentItem = item
        self.model().removeRows(0,  self.model().rowCount())
        """Load selected item properties"""
        self.delegates = []
        for k in item.shownFields:
            v = getattr(item, k)
            col1 = PropertyTreeItem(k)
            col1.setFlags(col1.flags()  & ~Qt.ItemIsEditable)            
            # if list, get current element
            if type(v) == list:
                if item.indP == None: continue
                v = v[item.indP]

            col2 = PropertyTreeItem(v)                
            col2.setEditable(True)
            col2.setData(QColor("#0000FF"), Qt.TextColorRole)
            self.model().appendRow([col1,  col2])     
            row = self.model().rowCount()-1                
            # custom delegates
            if k == 'startTime' or k == 'stopTime':
                self.delegates.append(TimeDelegate())
                self.setItemDelegateForRow(row,  self.delegates[-1])               
            if k == 'videoname' or k == 'imagename':
                sceneDir = os.path.dirname(str(self.currentItem.scene().filename))
                self.delegates.append(FileOpenDelegate(sceneDir))
                self.setItemDelegateForRow(row,  self.delegates[-1])                                   
            # font delegate
            if k == 'font':
                self.delegates.append(FontOpenDelegate())
                self.setItemDelegateForRow(row,  self.delegates[-1])       
                
        #### Begin display dymanic project variables 
        if type(item) != Path: 
            return
        ## Add Section Headers
        listItems = []
        for key, value in item.scene().variables.iteritems():
            listItem = [key]
            listItem.extend(value.toList())
            listItems.append(listItem)
        listItems.sort(key=operator.itemgetter(5))
        oldGroupName = None
        currentParent = None
        for name, vType, vShow, vShortcut,  vEachNode, vGroup, vChoices in listItems:
            if oldGroupName != vGroup.toString():
                self.model().appendRow([PropertyTreeItem(vGroup.toString()),  PropertyTreeItem()])     
                self.setFirstColumnSpanned(, self.model(), True)
                oldGroupName = vGroup.toString()
            if vShow.toBool():
                col1 = PropertyTreeItem(name)
                col1.setFlags(col1.flags()  & ~Qt.ItemIsEditable)            
                v = item.variables[name]
                if vEachNode.toBool(): # list
                    if item.indP == None: continue
                    v = v.toList()[item.indP]
                col2 = PropertyTreeItem(v)               
                col2.setEditable(True)
                col2.setData(QColor("#0000FF"), Qt.TextColorRole )
                col2.setData(True, EditorEnabledRole)
                self.model().appendRow([col1,  col2])     
                row = self.model().rowCount()-1
                if vType[0] == 'Yes/No':
                    self.delegates.append(CheckBoxDelegate())
                    self.setItemDelegateForRow(row,  self.delegates[-1])                   
                if vType[0] == 'String':
                    self.delegates.append(QStyledItemDelegate())
                    self.setItemDelegateForRow(row,  self.delegates[-1])                   
                elif vType[0] == 'DropDown':
                    choices = item.scene().variables[name].toList()[5].toPyObject()
                    self.delegates.append(DropDownDelegate(choices,  v))
                    self.setItemDelegateForRow(row,  self.delegates[-1])                                       
                elif vType[0] == 'Double':
                    self.delegates.append(DoubleDelegate())
                    self.setItemDelegateForRow(row,  self.delegates[-1])                                   
                elif vType[0] == 'Integer':
                    self.delegates.append(IntegerDelegate(row, 1))
                    self.setItemDelegateForRow(row,  self.delegates[-1])  
                elif vType[0] == 'Font':
                    self.delegates.append(FontDelegate())
                    self.setItemDelegateForRow(row,  self.delegates[-1])                                                                           
           #### End display dymanic project variables 

    def saveItem(self, item):
        """Save item properties: passing a PropertyTreeView properties"""
#        print 'saving item',  item
        for row in range(self.model().rowCount()):
            name = self.model().item(row,  0).data(Qt.EditRole).toPyObject()
            if name in item.scene().variables:  # temp
                #### Begin Save dymanic project variables             
                params = item.scene().variables[name].toList()
                if params[3].toBool(): # list
                    if item.indP == None: continue
                    li = item.variables[name].toList()
                    li[item.indP] = self.model().item(row,  1).data(Qt.EditRole)
                    item.variables[name] = QVariant(li)
                else:
                    item.variables[name] = self.model().item(row,  1).data(Qt.EditRole)
                #### End Save dymanic project variables 
            else:
                value = self.model().item(row,  1).data(Qt.EditRole)
                # load video if selected for the first time
    #            if name == 'videoname' and self.currentItem.videoname.toString()=='':
    #                self.currentItem.scene().loadVideoSignal.emit(value.toString())

                # if list: write to list element
                l = getattr(item, str(name))
                if type(l) == list:
                    if item.indP == None:
                        continue
                    else:
                        l[item.indP] = value
                        value = l
                setattr(item, str(name), value)

        if type(item) == Path:
            item.scene().updateItemListSignal.emit(item)

class PropertyTreeItem(QStandardItem):
    def __init__(self, data=None):
        QStandardItem.__init__(self)
        self.setData(data,  Qt.EditRole)

class PropertyTreeModel(QStandardItemModel):
    def __init__(self, parent=None):
        QStandardItemModel.__init__(self,  parent)
        self.setColumnCount (2)
        self.setHeaderData(0,  Qt.Horizontal,  'Property')
        self.setHeaderData(1,  Qt.Horizontal,  'Value')

