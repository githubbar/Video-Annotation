from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from heatmap import HeatMap        
from path import Path
from annotateview import AnnotateScene
from delegates import *
import os, threading, logging, time


class SearchWidget:
    matches = []

    def initSearchWidget(self):
        self.initCategories()        
        self.initTripTypes()
        self.results.setItemDelegate(URLDelegate())        
        self.results.cellDoubleClicked.connect(self.playResultItem)

    def initCategories(self):
        self.category.clearContents()
        self.category.setRowCount(0)        
        row = self.graphicsView.scene.readCategoriesFromFile(self.graphicsView.scene.categoriesPath)
        for i,  item in enumerate(row):
            self.category.insertRow(i)
            self.category.setItem(i, 0,  QTableWidgetItem(item))        
        self.category.sortItems(0)
        
    def initTripTypes(self):
        self.tripType.clearContents()
        self.tripType.setRowCount(0)        
        for i,  item in enumerate(AnnotateScene.tripTypeChoices):
            self.tripType.insertRow(i)
            self.tripType.setItem(i, 0,  QTableWidgetItem(item))        

    def searchClicked(self):
        # clear results
        self.matches = []            
        self.results.clearContents()
        self.results.setRowCount(0)        
        self.guiMode(self.GUI_SEARCH)                  
        threading.Thread(target=self.doSearch, name="doSearch").start()
        
    def doSearch(self):
        # scan all items
        for i in range(self.items.rowCount()):
            item = self.items.item(i, 0).g
            match = False
            self.emit(SIGNAL("updateProgress"), int(100.0*i/self.items.rowCount()) )
            # scan all nodes
            tripTypeMatch = False
            # ---------------- filter by tripType
            if len(self.tripType.selectedItems()) == 0: 
                tripTypeMatch = True
            else:
                for t in self.tripType.selectedItems():
                    if item.tripType.toString() == t.data(Qt.EditRole).toString():
                        tripTypeMatch = True
                        break
            
            for n in range(len(item.polygon)):            
                categoryMatch, timeMatch, phoneMatch, employeeMatch, shoppedMatch,  purchasedMatch = False, False, False, False, False, False
                # ---------------- filter by category
                cat = item.category[n]
                if len(self.category.selectedItems()) == 0: 
                    categoryMatch = True
                else:
                    for c in self.category.selectedItems():
                        if cat.toString() == c.data(Qt.EditRole).toString():
                            categoryMatch = True
                            break
                            
                # ---------------- filter by start and stop time
                t1 = item.startTime[n].toTime()
                t2 = item.stopTime[n].toTime()
        
                if not self.timeCheckBox.isChecked() or (t1 > self.startTimeFilter.time() and t2 < self.stopTimeFilter.time()):
                    timeMatch = True
                if not self.phoneCheckBox.isChecked() or item.phone[n].toBool():
                    phoneMatch = True                    
                if not self.employeeCheckBox.isChecked() or item.employee[n].toBool():
                    employeeMatch = True                    
                if not self.shoppedCheckBox.isChecked() or item.shopped[n].toBool():
                    shoppedMatch = True                    
                if not self.purchasedCheckBox.isChecked() or item.purchased[n].toBool():
                    purchasedMatch = True                   
                    
                # combine search criteria
                match = categoryMatch and tripTypeMatch and timeMatch and phoneMatch and employeeMatch and shoppedMatch and  purchasedMatch
                if match: self.matches.append(Match(item, n))
                if not self.go: break                
        self.emit(SIGNAL("completeProgress"), self.GUI_NORMAL)
        
       
    def refreshResults(self):
        for i,  match in enumerate(self.matches):
            self.results.insertRow(i)
            cID = QTableWidgetItem(match.item.id.toString())
            cTime = QTableWidgetItem(match.toString())
            cID.setData(Qt.UserRole, match.item.id)
            cTime.setData(Qt.UserRole , QVariant(match))
            cID.setForeground(QBrush(QColor("blue")))
            cTime.setForeground(QBrush(QColor("blue")))
            self.results.setItem(i, 0,  cID)    
            self.results.setItem(i, 1,  cTime)    

    def playResultItem(self, row, col):
        # FIXME: double-click event handler is called twice
        self.tabWidget.setCurrentIndex(0)
        self.checkAllItems(False)       
        result = self.results.item(row,  1).data(Qt.UserRole).toPyObject()        
        self.graphicsView.scene.currentPath = result.item
        self.graphicsView.scene.currentPath.indP = result.n
        self.changeCurrentItem()      
        if self.mediaPlayer.play() != -1:            
            self.playButton.setIcon(QIcon('icons/player_pause.png'))
            self.timer.start()
            self.isPaused = False        
        # Wait for mediPlayer  to play after playClicked()        
        for i in range(100): 
            time.sleep(0.01) 
            if self.mediaPlayer.is_playing(): break
        self.updateVideo(self.graphicsView.scene.currentPath)        
        

    def visClicked(self):
        self.guiMode(self.GUI_EXPORT)                  
        paletteFile='palettes/jet.png'
        W = int(self.graphicsView.scene.width())
        H = int(self.graphicsView.scene.height())
        heatmapBox=[0,  W,  0,  H]
        hm = HeatMap(heatmapBox[0], heatmapBox[1], heatmapBox[2],  heatmapBox[3],  paletteFile)
        # add data points        
        hp = []
        for i,  match in enumerate(self.matches):
            self.progressBar.setValue(int(100.0*i/len(self.matches)))         
            self.searchWidget.repaint()          
            if not self.go: 
                hp = []
                break                
            n = match.n
            addThis = True
#            if self.visPurchased.isChecked(): addThis &= match.item.purchased[n].toBool()
#            if self.visShopped.isChecked(): addThis &= match.item.shopped[n].toBool()
            if not addThis: continue
            # create as many points as there are seconds
            if self.visUseTime.isChecked():
                count = match.item.startTime[n].toTime().secsTo(match.item.stopTime[n].toTime())
            else: count = 1
            for c in range(count):
                hp += [(match.item.polygon.at(n).x(), match.item.polygon.at(n).y())]

        hm.add_points(hp, self.visRadius.value()) 
        hm.transform_color(0.01*self.visAlpha.value())
        p = QPixmap.fromImage(QImage(hm.get_image_buffer(), hm.width,  hm.height,  QImage.Format_ARGB32))
        self.graphicsView.scene.heatmap.setPixmap(p)
        self.graphicsView.scene.heatmap.setVisible(True)          
        self.guiMode(self.GUI_NORMAL)          
        
    def exportVideoClicked(self):
        # choose export folder
        outDir = QFileDialog.getExistingDirectory(self, "Choose Folder to Export To", os.getcwdu())
        if not outDir:
            return        
        self.guiMode(self.GUI_EXPORT)                  
        threading.Thread(target=self.doExportVideo, name="exportVideoThread",  args=(outDir, )).start()
        
    def doExportVideo(self, outDir):
        import subprocess, re        
 
        for i,  match in enumerate(self.matches):
#            print str(int(100.0*i/len(self.matches)))            
            self.emit(SIGNAL("updateProgress"), int(100.0*i/len(self.matches)))
            
            inFileName = os.path.join(os.path.dirname(str(self.graphicsView.scene.filename)), str(match.item.videoname.toString()))
  
            t1 = match.item.startTime[match.n].toTime()
            t2 = match.item.stopTime[match.n].toTime()
           
            cat = match.item.category[match.n].toString()
            cat = cat.replace('/', '-')
            cat = cat.replace(':', '-')
            outFileName = os.path.join(str(outDir), str(match.item.id.toString()+' from '+t1.toString('hh-mm-ss')+' to '+t2.toString('hh-mm-ss')+' ' \
            +cat+'.avi'))
            if os.path.exists(inFileName):
                logging.debug('Current working directory is '+str(os.getcwd()))              
                p = subprocess.Popen(['ffmpeg', '-ss', str(QTime().secsTo(t1)), '-t',  str(t1.secsTo(t2)), '-i', str(inFileName), \
                '-async',  '1', '-y',  str(outFileName)],  shell=True)
                p.wait()
                logging.debug('ffmpeg'+ ' -ss '+ str(QTime().secsTo(t1))+ ' -t ' +  str(t1.secsTo(t2)) + ' -i ' + str(inFileName)+ ' -y '+  str(outFileName))
            if not self.go: break
        self.emit(SIGNAL("completeProgress"), self.GUI_NORMAL)
       
    def exportDataClicked(self):
        self.guiMode(self.GUI_EXPORT)
        # choose export file
        outFileName = QFileDialog.getSaveFileName(self, "Choose File to Export To", os.getcwdu())
        if outFileName:
            writer = csv.writer(open(outFileName, 'wb'))            
            writer.writerow(['id', 'node number', 'startTime', 'stopTime',  'category', 'tripType', 'purchased', 'shopped',  'phone', 'employee'])
            for i,  match in enumerate(self.matches):
                self.progressBar.setValue(int(100.0*i/len(self.matches)))         
                print str(int(100.0*i/len(self.matches)))            
                self.searchWidget.repaint()          
                writer.writerow([str(match.item.id.toString()), str(match.n), \
                  str(match.item.startTime[match.n].toTime().toString('hh-mm-ss')),  \
                  str(match.item.stopTime[match.n].toTime().toString('hh-mm-ss')),  \
                  str(match.item.tripType.toString()),  \
                  str(match.item.purchased[match.n].toString()),  \
                  str(match.item.shopped[match.n].toString()),  \
                  str(match.item.phone[match.n].toString()),  \
                  str(match.item.employee[match.n].toString()) \
                                  ])
                if not self.go: break
        self.guiMode(self.GUI_NORMAL)  

    def cancelClicked(self):
        self.go = False
        
    def updateProgress(self,  now):
        self.progressBar.setValue(now)
        self.searchWidget.repaint()     
        
    def guiMode(self,  searchMode=None):
        if searchMode == self.GUI_NORMAL or searchMode == None:
            self.go = False
            self.searchCancel.hide()                     
            self.exportCancel.hide()                  
            self.progressBar.reset()
            self.progressBar.hide() 
            self.searchButton.setEnabled(True) 
            self.exportData.setEnabled(True) 
            self.exportVideo.setEnabled(True)       
            self.refreshResults()
            
        elif searchMode == self.GUI_EXPORT:
            self.go = True
            self.exportCancel.show()            
            self.progressBar.reset()
            self.progressBar.show() 
            self.searchButton.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.exportData.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.progressBar.setValue(0)     
            self.searchWidget.repaint() 
        elif searchMode == self.GUI_SEARCH:
            self.go = True
            self.progressBar.setValue(100)         
            self.searchCancel.show()            
            self.progressBar.reset()
            self.progressBar.show() 
            self.searchButton.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.exportData.setEnabled(False) 
            self.exportVideo.setEnabled(False) 
            self.progressBar.setValue(0)     
            self.searchWidget.repaint() 
        
class Match:
    def __init__(self, item,  n):
        self.item = item
        self.n = n

    def toString(self):
        return self.item.startTime[self.n].toTime().toString('hh:mm:ss')
