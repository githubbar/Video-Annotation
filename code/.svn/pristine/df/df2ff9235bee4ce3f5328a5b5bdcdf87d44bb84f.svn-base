# -*- coding: utf-8 -*-
"""
Annotation Tool: For annotating path time series over human tracking video
Copyright: Alex Leykin @ CIL
Email: cil@indiana.edu
http://indiana.edu/~cil
Software bindings: 
"""

# Import modules
import os,sys
from random import randint, shuffle
from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from label import *
from path import *
from polygon import *
from rectangle import *
from ellipse import *
from commands import *
from snapshot import *

class AnnotateScene(QGraphicsScene):
    loadSignal  = pyqtSignal(QGraphicsItem)
    saveSignal  = pyqtSignal(QGraphicsItem)
    loadVideoSignal  = pyqtSignal(QString)    
    updateVideoSignal = pyqtSignal(QGraphicsItem)      
    addItemListSignal = pyqtSignal(QGraphicsItem)          
    removeItemListSignal = pyqtSignal(QGraphicsItem)          
    updateItemListSignal = pyqtSignal(QGraphicsItem)              
    changeCurrentItemSignal = pyqtSignal()        
    modes = ('Select', 'Path', 'Separator', 'Edit', 'Polygon',  'Rectangle',  'Label', 'Snapshot')    
    gridD = 1
    currentPath = None        
    currentPolygon = None    
    categoriesPath = ''
    backgroundPath = ''
    tripTypeChoices = ['fill in', 'routine', 'stock up', 'occasion']     
    categoryChoices = []
    time = QTime()
    
    def __init__(self):
        QGraphicsScene.__init__(self)
        # Undo stack
        self.undoStack = QUndoStack(self)      
        self.setSceneRect(0,  0,  320.0, 180.0)
        self.clear()
        
    def clear(self):
        QGraphicsScene.clear(self)
        self.heatmap = QGraphicsPixmapItem()
        self.background = QGraphicsPixmapItem()
        self.addItem(self.heatmap)
        self.addItem(self.background)
        self.heatmap.setZValue(-1)
        self.background.setZValue(-2)        
        self.heatmap.setVisible(False) 
        self.filename = None
        self.currentPath = None
        self.currentPolygon = None              
        self.categoriesPath = ''
        self.backgroundPath = ''  
        self.s = None      # current stacking item index
        
    def removeItem(self,  item):
        if type(item) == Path:
            self.removeItemListSignal.emit(item)
            self.currentPath = None
        QGraphicsScene.removeItem(self, item)

    def addItem(self,  item):
        QGraphicsScene.addItem(self, item)
        if type(item) == Path:
            self.addItemListSignal.emit(item)
            self.currentPath = item
    
    def readCategoriesFromFile(self,  fileName):
        if fileName==None or fileName=='':
            return ''
        import csv
        reader = csv.reader(open(fileName, 'rb'))
        for row in reader:
            return row

    def updateProjectProperties(self):
        self.removeItem(self.background)
        self.background = QGraphicsPixmapItem()
        self.addItem(self.background)        
        if self.backgroundPath != '' and self.backgroundPath != None:
            pixmap = QPixmap(os.path.join(os.path.dirname(str(self.filename)), self.backgroundPath))
            self.background.setPixmap(pixmap)
            self.background.scale((self.width()+1)/pixmap.width(),  (self.height()+1)/pixmap.height())
            self.background.setZValue(-2)        

        if self.categoriesPath != '' and self.categoriesPath != None:                
            self.categoryChoices = self.readCategoriesFromFile(os.path.join(os.path.dirname(str(self.filename)), self.categoriesPath))
            self.categoryChoices.sort()

    def load(self, s, buildNumber, merge = False):
        # read scene properties
        w = s.readFloat()
        h = s.readFloat()
        self.setSceneRect(0,  0,  w, h)
        # read categories Path and Backgound Image Path
        if (buildNumber > 39):
            self.categoriesPath = s.readString()
            self.backgroundPath = s.readString()
        self.updateProjectProperties()
            
        # read items
        nItems = s.readInt()
        for i in range(nItems):
            cItem = s.readQString()
            item = eval(str(cItem)+'()') # create an item instance of appropriate type
            if type(item) == QGraphicsPixmapItem:
                continue                      
            item.read(s)
            if merge:
                if type(item) == Path:
                    self.addItem(item)            
            else:
                self.addItem(item)    
            
    def save(self, s):
        # write scene properties
        s.writeFloat(self.width())
        s.writeFloat(self.height())
        # write categories Path and Backgound Image Path
        s.writeString(self.categoriesPath)
        s.writeString(self.backgroundPath)
        # write items
        s.writeInt(len(self.items())-2) # minus the heatmap and the background image
        for i in self.items():
            # skip heatmap
            if type(i) == QGraphicsPixmapItem:
                continue            
            s.writeQString(i.__class__.__name__)
            i.write(s)
        
class AnnotateView(QGraphicsView):
    
    def __init__(self, parent):
        QGraphicsView.__init__(self,  parent)
        self.scene= AnnotateScene()
        self.setScene(self.scene)
#        self.scene.setSceneRect(0, 0, 320, 180)
        Z = 1.0
        self.FONT_ZOOM_FACTOR = 1.1
        self.scale(Z, Z)
        self.scene.mode = self.scene.modes[0]
        self.font = QFont('Verdana', 2.2)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.scene.filename = ''
        zoomInFontKey = QAction(self)
        zoomInFontKey.setShortcut(QKeySequence('Ctrl+='))
        zoomInFontKey.triggered.connect(self.zoomInFontPressed)                 
        self.addAction(zoomInFontKey)
        zoomOutFontKey = QAction(self)
        zoomOutFontKey.setShortcut(QKeySequence('Ctrl+-'))
        zoomOutFontKey.triggered.connect(self.zoomOutFontPressed)                 
        self.addAction(zoomOutFontKey)
        startTimeKey = QAction(self)
        startTimeKey.setShortcut(Qt.Key_F1)        
        startTimeKey.triggered.connect(self.startTimeKeyPressed)           
        self.addAction(startTimeKey)        
        stopTimeKey = QAction(self)
        stopTimeKey.setShortcut(Qt.Key_F2)        
        stopTimeKey.triggered.connect(self.stopTimeKeyPressed)           
        self.addAction(stopTimeKey)
        purchaseKey = QAction(self)
        purchaseKey.setShortcut(Qt.Key_F3)        
        purchaseKey.triggered.connect(self.purchaseKeyPressed)           
        self.addAction(purchaseKey)
        interactionKey = QAction(self)
        interactionKey.setShortcut(Qt.Key_F4)        
        interactionKey.triggered.connect(self.interactionKeyPressed)           
        self.addAction(interactionKey)
        phoneKey = QAction(self)
        phoneKey.setShortcut(Qt.Key_F5)        
        phoneKey.triggered.connect(self.phoneKeyPressed)           
        self.addAction(phoneKey)
        employeeKey = QAction(self)
        employeeKey.setShortcut(Qt.Key_F6)        
        employeeKey.triggered.connect(self.employeeKeyPressed)           
        self.addAction(employeeKey)
        
    def zoomInFontPressed(self):
        for i in self.scene.selectedItems():
            f = i.font.toPyObject() 
            f.setPointSizeF(f.pointSizeF()*self.FONT_ZOOM_FACTOR)
            i.font = QVariant(f)
            self.scene.loadSignal.emit(i)
        self.scene.update()    

    def zoomOutFontPressed(self):
        for i in self.scene.selectedItems():
            f = i.font.toPyObject() 
            f.setPointSizeF(f.pointSizeF()/self.FONT_ZOOM_FACTOR)
            i.font = QVariant(f)
            self.scene.loadSignal.emit(i)
        self.scene.update()    

    def startTimeKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.startTime[self.scene.currentPath.indP] = QVariant(self.scene.time)
            self.scene.loadSignal.emit(self.scene.currentPath)
            
    def stopTimeKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP  != None:
            self.scene.currentPath.stopTime[self.scene.currentPath.indP] = QVariant(self.scene.time)
            self.scene.loadSignal.emit(self.scene.currentPath)

    def purchaseKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.purchased[self.scene.currentPath.indP] = QVariant(not self.scene.currentPath.purchased[self.scene.currentPath.indP].toBool())
            self.scene.loadSignal.emit(self.scene.currentPath)
            
    def interactionKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.shopped[self.scene.currentPath.indP] = QVariant(not self.scene.currentPath.shopped[self.scene.currentPath.indP].toBool() )
            self.scene.loadSignal.emit(self.scene.currentPath)

    def phoneKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.phone[self.scene.currentPath.indP] = QVariant(not self.scene.currentPath.phone[self.scene.currentPath.indP].toBool() )
            self.scene.loadSignal.emit(self.scene.currentPath)

    def employeeKeyPressed(self):
        if self.scene.currentPath and self.scene.currentPath.indP != None:
            self.scene.currentPath.employee[self.scene.currentPath.indP] = QVariant(not self.scene.currentPath.employee[self.scene.currentPath.indP].toBool() )
            self.scene.loadSignal.emit(self.scene.currentPath)
            
            
    def mousePressEvent(self, event):
        # cycle through stacking order if more than 1 item under mouse
        items = self.items(event.pos())        
        if event.modifiers() == Qt.NoModifier and len(items) > 1: 
            if not self.scene.s: self.scene.s = items[0]       
            else:
                try:
                    N = items.index(self.scene.s)
                except ValueError:
                    N = 0
                self.scene.s = items[(N+1) % len(items)]
                self.scene.s.stackBefore(items[N])
          
        if (event.buttons() & Qt.LeftButton):
            sp = self.mapToScene(event.pos())
            # copy item with alt+Drag
            if self.scene.mode == 'Edit' and (event.modifiers() & Qt.AltModifier):
                for i in self.scene.selectedItems():
                    item = eval('i.clone()')
                    self.scene.undoStack.push(AddCommand(self.scene, item))                                             
            elif self.scene.mode == 'Path':                
                # Add new path
                if (not self.scene.currentPath or event.modifiers() & Qt.ShiftModifier):
                    self.scene.currentPath = Path(self.font, 1.0)
                    self.scene.undoStack.push(AddCommand(self.scene, self.scene.currentPath))                                             
                if not self.scene.currentPath.choosingOrientation and not event.modifiers() & Qt.ControlModifier:
                    self.scene.currentPath.handleLeftMousePress(sp, event.modifiers(), self.scene.time)
            elif self.scene.mode == 'Polygon':           
                if (not self.scene.currentPolygon or event.modifiers() & Qt.ShiftModifier):   
                    self.scene.currentPolygon = Polygon(self.font, 0.4)
                    self.scene.undoStack.push(AddCommand(self.scene, self.scene.currentPolygon))                                             
                self.scene.currentPolygon.addPoint(sp, self.scene.time)                                 
            elif self.scene.mode == 'Rectangle':             
                self.scene.undoStack.push(AddCommand(self.scene, Rectangle(sp,  self.font, 0.4)))                                             
            elif self.scene.mode == 'Ellipse':                
                self.scene.undoStack.push(AddCommand(self.scene, Ellipse(sp,  self.font, 0.4))) 
            elif self.scene.mode == 'Label':                
                self.scene.undoStack.push(AddCommand(self.scene, Label(sp,  self.font, 0.4)))                 
            elif self.scene.mode == 'Snapshot':                
                self.scene.undoStack.push(AddCommand(self.scene, Snapshot(sp,  self.font, 0.4)))                                 
        elif (event.buttons() & Qt.RightButton):
            sp = self.mapToScene(event.pos())
            if self.scene.mode == 'Path':                
                self.scene.currentPath.handleRightMousePress(sp, event.modifiers(), self.scene.time)
                    
        QGraphicsView.mousePressEvent(self,  event)        

#Size scene to fit the view
    def fitSceneInView(self):
        self.setTransform(QTransform())
        s = min(self.width()/self.scene.width(), self.height()/self.scene.height())
        self.scale(s, s);
        
    def wheelEvent(self, event):
        factor = 1.2
        if event.delta() < 0:
            factor = 1.0 / factor
        self.scale(factor, factor)

    def drawBackground (self, painter,  r):
        QGraphicsView.drawBackground(self,  painter,  r)
        painter.setPen(QColor("black"))
        painter.setOpacity(0.1)
        r = self.sceneRect()
        x = r.left()
        while x <= r.right():
            painter.drawLine(x, r.top(), x, r.bottom())     
            x += self.scene.gridD
        y = r.top()            
        while y <= r.bottom():
            painter.drawLine(r.left(), y, r.right(), y)     
            y += self.scene.gridD          
