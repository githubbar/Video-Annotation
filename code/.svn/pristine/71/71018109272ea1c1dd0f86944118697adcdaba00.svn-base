# -*- coding: utf-8 -*-
""" Path Item"""

from PyQt4.QtGui import *
from PyQt4.QtCore import *
import os, datetime, threading, subprocess, time, sys, csv

from settings import *
from propertywidget import *
from delegates import *
from commands import *

class Path(QGraphicsPathItem):
    id, videoname = QVariant(),  QVariant()
    startTime, stopTime = [], []
    shownFields = ['id', 'videoname', 'startTime', 'stopTime']
    p0 = None # placeholder for the first point
    indP = None # current node index
    R = 1.0 # node radius 
    K= 6.0 # orientation line length compared to R    
    penR = 0.3 # edge width
    
    def __init__(self, point=None, font=QFont('White Rabbit',  2),  opacity=1.0):    
        QGraphicsPathItem.__init__(self)
        self.stroker = QPainterPathStroker()        
        self.stroker.setWidth(1*self.R)        
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsFocusable | QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemClipsToShape | QGraphicsItem.ItemSendsGeometryChanges)
        self.videoname = QVariant(QString(''))
        self.setBrush(QColor(Qt.transparent))
        self.setPen(QPen(QBrush(Qt.blue), self.penR))
        self.setCursor(Qt.ArrowCursor)
        self.polygon = QPolygonF()     
        self.orientation = QPolygonF()     
        self.setOpacity(opacity)
        self.font = QVariant(font)
        self.p0 = point
        self.choosingOrientation = False
        self.variables = dict()
                      
    def shape(self):
        sh = self.stroker.createStroke(self.path())
        for i in range(self.polygon.count()):
            sh.addEllipse(self.polygon[i],  self.K,  self.K)
            if self.scene().currentPath == self:
                # Expand for video position indicator
                if i>0 and self.scene().time > self.stopTime[i-1].toTime() and self.scene().time < self.startTime[i].toTime():
                    sh.addEllipse(self.getSegmentPosInTime(i-1, self.scene().time), 2*self.R+2, 2*self.R+2) 
        return sh

    def write(self, s):
#        for i in range(len(self.description)):
#            if self.tags[i].toString() == '':
#                self.tags[i] = self.description[i]
#                self.description[i] = QVariant('')
#            i += 1

#        self.videoname = QVariant(os.path.join('videos',os.path.split(str(self.videoname.toString()))[1]))        


        s.writeQVariant(self.id)
        s.writeQVariant(self.videoname)        
        s.writeQVariantList(self.startTime)        
        s.writeQVariantList(self.stopTime)        

#        s.writeQVariant(self.tripType)        
#        s.writeQVariantList(self.description)
#        s.writeQVariantList(self.tags)
#        s.writeQVariantList(self.purchased)
#        s.writeQVariantList(self.shopped)                
#        s.writeQVariantList(self.category)
#        s.writeQVariantList(self.phone)
#        s.writeQVariantList(self.employee)        
        
        s.writeQVariantMap(self.variables)        
        s << self.polygon        
        s << self.orientation
        s.writeFloat(self.opacity())
        s << self.font

    def read(self, s, buildNumber):

        self.id = s.readQVariant()
        self.videoname =  s.readQVariant()
        vars = range(8)
        if (buildNumber < 41):            
            vars[0] =  s.readQVariant()
            vars[1] = s.readQVariantList()
            vars[2] = s.readQVariantList()
        self.startTime = s.readQVariantList()
        self.stopTime = s.readQVariantList()
        if (buildNumber < 41):                    
            vars[3] = s.readQVariantList()        
            vars[4] = s.readQVariantList()        
            vars[5] =  s.readQVariantList()         
            vars[6] = s.readQVariantList()        
            vars[7]= s.readQVariantList()        
        if (buildNumber >= 41):            
            self.variables = s.readQVariantMap()  
        else:
            for i, name in enumerate(['tripType','description', 'tags',  'purchased', 'shopped',  'category', 'phone', 'employee'] ):
                self.variables[QString(name)] = QVariant(vars[i])
        s >> self.polygon
        s >> self.orientation
        self.setOpacity(s.readFloat())
        s >> self.font             
          
        
    def addQuadFromPolygon(self,  path, polygon):
        if polygon.count() == 0:
            return
        path.moveTo(polygon.at(0))
        # add temporary points
        polygon.prepend(polygon.at(0))
        polygon.append(polygon.at(polygon.count()-1))       
        
        for i in range(1, polygon.count()-2):
            c1, c2 = self.getControlPoints(polygon.at(i-1), polygon.at(i), polygon.at(i+1), polygon.at(i+2))
            path.cubicTo(c1, c2, polygon.at(i+1))
        
        # remove temporary points
        polygon.remove(0)
        polygon.remove(polygon.count()-1)

        
    def getControlPoints(self, p0, p1, p2, p3):
        if p0 == p1 or p1 == p2 or p2 == p3:
            return (p1*2.0+p2)/3.0, (p1+p2*2.0)/3.0        
        K = 1.0
        c1 = (p0 + p1) / 2.0
        c2 = (p1 + p2) / 2.0
        c3 = (p2 + p3) / 2.0
        len1 = math.sqrt((p1-p0).x()**2 + (p1-p0).y()**2)
        len2 = math.sqrt((p2-p1).x()**2 + (p2-p1).y()**2)
        len3 = math.sqrt((p3-p2).x()**2 + (p3-p2).y()**2)

        k1 = len1 / (len1 + len2)
        k2 = len2 / (len2 + len3)

        m1 = c1 + (c2 - c1) * k1
        m2 = c2 + (c3 - c2) * k2
        cp1 = (c2 - m1) * self.scene().pathSmoothingFactor + p1
        cp2 = (c2 - m2) * self.scene().pathSmoothingFactor + p2
        return cp1, cp2
        
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        QGraphicsPathItem.paint(self, painter, option, widget)
        painter.setFont(self.font.toPyObject())
        painter.setPen(Qt.red)     
        
        # draw Orientations only for active path
        if self.scene().currentPath == self:
            for i in range(self.polygon.count()):
                line = QLineF(self.polygon.at(i),  self.orientation.at(i))
                line.setLength(self.K*self.R)
                painter.drawLine(line)             
            
        for i in range(self.polygon.count()):
            painter.setPen(Qt.red)              
            if self.scene().currentPath == self and self.indP == i:
                painter.setBrush(QBrush(Qt.red))
            elif self.variables[QString('purchased')].toList()[i].toBool():
                painter.setBrush(QBrush(Qt.green))
            elif self.variables[QString('shopped')].toList()[i].toBool():
                painter.setBrush(QBrush(Qt.blue))     
            else:
                painter.setBrush(QBrush(Qt.transparent))                                
            painter.drawEllipse(self.polygon.at(i), self.R, self.R) 
            # Paint video position indicator and auto-load properties during playback
            if self.scene().currentPath == self:
                painter.setBrush(QBrush(Qt.transparent))                                
                painter.setPen(QPen(QBrush(Qt.red), 2))                 
                if i>0 and self.scene().time > self.stopTime[i-1].toTime() and self.scene().time < self.startTime[i].toTime():
                    painter.drawEllipse(self.getSegmentPosInTime(i-1, self.scene().time), 2*self.R, 2*self.R) 
                elif self.scene().time > self.startTime[i].toTime() and self.scene().time < self.stopTime[i].toTime():
                    painter.drawEllipse(self.polygon.at(i), 2*self.R, 2*self.R) 
                    self.indP = i
                    self.scene().loadSignal.emit(self)     
    
    def getSegmentPosInTime(self, i, t):
       #FIXME: disk should travel along spline
        t0 = QTime().msecsTo(t)
        t1 = QTime().msecsTo(self.stopTime[i].toTime())
        t2 = QTime().msecsTo(self.startTime[i+1].toTime())
        p1 = self.polygon.at(i)
        p2 = self.polygon.at(i+1)
        p = QPointF((p2.x()*(t0-t1)+p1.x()*(t2-t0))/(t2-t1),  (p2.y()*(t0-t1)+p1.y()*(t2-t0))/(t2-t1))
        return p
            
    def updatePoint(self, i, p):
        if i == None:
            return        
        self.polygon.replace(i,  p)
        path = QPainterPath()
        self.addQuadFromPolygon(path, self.polygon)
        self.setPath(path)
    
    def updatePointCommand(self, i, p):
        if i == None:
            return        
        self.scene().undoStack.push(UpdatePointCommand(self,  i, p))
        
    def updateOrientation(self, i, p):
        if i == None:
            return        
        self.orientation.replace(i,  p)

    def updateOrientationCommand(self, i, p):
        if i == None:
            return        
        self.scene().undoStack.push(UpdateOrientationCommand(self,  i, p))            

    def deletePoint(self):
        if self.indP == None or self.indP == 0 and len(self.polygon) == 1:
            self.scene().undoStack.push(RemoveCommand(self.scene(), self))                            
        else:
            self.scene().undoStack.push(RemovePointCommand(self,  self.indP, self.polygon[self.indP]))                                             
    
        
    def addPoint(self, p, time):
        self.scene().undoStack.push(AddPointCommand(self,  len(self.polygon), p, time))                                             
        
    def insertPoint(self, i, p):
        if len(self.polygon) < 2 or i >= len(self.polygon)-1: 
            return
        self.scene().undoStack.push(AddPointCommand(self,  i+1, p))                                             

    def getNearestPoint(self, p):
        mini=0
        mind = sys.maxint
        for i in range(self.polygon.count()):
            dist = (self.polygon.at(i)-p).manhattanLength()
            if  dist < mind:
                mind = dist
                mini = i
        return mini

    def getNearestLineSegment(self, p):
        if self.polygon.count() < 2:
            return 0
        i1 = 0
        d1 = sys.maxint
        for i in range(self.polygon.count()-1):
            l = QLineF(self.polygon.at(i), self.polygon.at(i+1))
            n = l.normalVector()
            n.translate(p-n.p2())
            ip = QPointF() 
            res = l.intersect(n, ip)
            n = QLineF(ip, p)
            res = l.intersect(n, ip)
            if res == QLineF.UnboundedIntersection:
                dist = min([(p-l.p1()).manhattanLength(), (p-l.p2()).manhattanLength()])
            elif res == QLineF.BoundedIntersection:
                dist = (p-ip).manhattanLength()
            else:
                continue
            if dist < d1:
                d1 = dist
                i1 = i
        return i1
        
    def focusInEvent (self, event):
        QGraphicsItem.focusInEvent(self, event)
        self.scene().loadSignal.emit(self)     
        self.scene().currentPath = self
        self.scene().changeCurrentItemSignal.emit()

    def focusOutEvent (self, event):
        QGraphicsItem.focusOutEvent(self, event)
        if self.polygon.count():
            self.scene().saveSignal.emit(self)

    def handleMousePress(self, event):
        print 'handle mouse over path ' + self.id.toString()
        # get new point closest to mouse and load it        
        sp = event.scenePos()        
        self.indP = self.getNearestPoint(sp)
#            QGraphicsPathItem.mousePressEvent(self,  event)             
        if (event.buttons() & Qt.LeftButton): 
            if not self.choosingOrientation:
                # save old point
                if (event.modifiers() & Qt.ControlModifier):
                    # add new point between two closest points
                    i = self.getNearestLineSegment(sp)
                    self.insertPoint(i, sp)
                elif self.indP != None and (sp-self.polygon.at(self.indP)).manhattanLength() <= self.scene().gridD:
                    self.updatePointCommand(self.indP, sp)
                else:
                    self.addPoint(sp, self.scene().time)   
        elif (event.buttons() & Qt.RightButton): 
            self.choosingOrientation = True    
            
    def mousePressEvent(self, event):
        print 'mouse press over path ' + self.id.toString()
        self.indP = self.getNearestPoint(event.scenePos())
        self.scene().loadSignal.emit(self)
        self.scene().currentPath = self
        self.setSelected(True)          
        self.scene().updateVideoSignal.emit(self)               
        self.update()     

    def populateVariables(self):
        for name in self.scene().variables:
            params = self.scene().variables[name].toList()
            if not name in self.variables:                                
                if params[3].toBool():
                    self.variables[name] = QVariant([])
                else:
                    self.variables[name] = QVariant()                
                
    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemSceneHasChanged and self.scene():
            self.populateVariables()            
            if (self.polygon.count() == 0 and self.p0):
                self.addPoint(self.p0, self.scene().time)   
                self.p0 = None 
            path = QPainterPath()
            self.addQuadFromPolygon(path, self.polygon)
            self.setPath(path)
            
        if (change == QGraphicsItem.ItemSelectedHasChanged):
            if self.isSelected():
                self.setPen(QPen(QBrush(QColor(255, 165, 0)), self.penR*1.5))    
#                unselect all other items in the scene
                for i in self.scene().selectedItems():
                    if i != self:
                        i.setSelected(False)
            else: 
                self.setPen(QPen(QBrush(Qt.blue), self.penR))      
        return QGraphicsItem.itemChange(self, change, value)
        
    def mouseReleaseEvent(self, event):                
            # TODO: choosing orientation undo !!!
#            self.updateOrientationCommand(self.indP, sp)
        self.scene().loadSignal.emit(self)            
        self.choosingOrientation = False

    def mouseMoveEvent(self, event):
        if self.scene().mode == 'Path' and self.indP != None:
            if self.choosingOrientation:
                self.updateOrientation(self.indP, event.pos())
                self.update()
            else:
                self.updatePoint(self.indP, event.pos())
        
    def keyPressEvent(self, event):
        print 'Path key press'
        if event.key() == Qt.Key_Delete:
            self.deletePoint()
            

    def toString(self):
        return self.id
