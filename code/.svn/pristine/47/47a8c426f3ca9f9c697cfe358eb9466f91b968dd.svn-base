# -*- coding: utf-8 -*-
"""
Annotation Tool: For annotating path time series over human tracking video
Copyright: Alex Leykin @ CIL
Email: cil@indiana.edu
http://indiana.edu/~cil
Software bindings: 
    
Developed with: 
    Python 2.7 x32bit (http://www.python.org/download/releases/2.7.1/)
    Python modules: 
        PyQt: http://www.riverbankcomputing.co.uk/software/pyqt/download    
        PyWin32: http://sourceforge.net/projects/pywin32/ (windows extensions, need it for system uptime)
        
    Eric4 python IDE (http://eric-ide.python-projects.org/eric-download.html)
    Cx-freeze: http://cx-freeze.sourceforge.net/ (to make executables)
    
====================================================================================

SVN commits go to: https://bl-bus-leykin10.ads.iu.edu:8443/svn/VA2/
"""

# Import modules
import os, sys
from Ui_window import Ui_MainWindow
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from annotateview import *
from tablewidget import *
from commands import *
import vlc
import menu, buttonevents, searchwidget, visualizewidget, help


# Create a class for our main window
class Main(QMainWindow,  Ui_MainWindow, buttonevents.ButtonEvents,  searchwidget.SearchWidget,  visualizewidget.VisualizeWidget):
    GUI_NORMAL = 0
    GUI_SEARCH = 1
    GUI_EXPORT = 2
    BUILD_NUMBER = 38
    go = False   # search/export thread is not running
    def __init__(self):
        QMainWindow.__init__(self)
        Ui_MainWindow.__init__(self)
        self.setupUi(self)
        
        self.help = None
        
        # Menu
        menu.createMenu(self)

        # Toolbar
        self.toolbar = QToolBar(self)
        self.actions = []
        for i, text in enumerate(self.graphicsView.scene.modes):
            action = QAction(QIcon('icons/'+text+'.png'), text, self)
            if text != 'Separator':
                action.setShortcut('Ctrl+'+str(i+1))
                action.setCheckable(True)
                self.actions.append(action)
                action.triggered.connect(self.handleToolbarButton)
            else:
                action.setSeparator(True)
            self.toolbar.addAction(action)
        self.actions[0].setChecked(True)
#        self.addToolBar(Qt.TopToolBarArea,  self.toolbar)
        self.toolbar.setOrientation(Qt.Vertical)
        self.gridLayout.addWidget(self.toolbar,  0, 0, -1, 1)

        # Video View
        self.Instance = vlc.Instance('--fullscreen')
        self.mediaPlayer = self.Instance.media_player_new()
        self.isPaused = True
        self.playButton.setIcon(QIcon('icons/player_play.png'))
        self.timer = QTimer(self)
        self.timer.setInterval(200)
        
        self.fullScreen = False
        toggleFullscreen = QAction(self)
        toggleFullscreen.setShortcut(Qt.Key_F11)        
        toggleFullscreen.triggered.connect(self.handleFullScreen)    
        self.addAction(toggleFullscreen)       
        setRate = QAction(self)
        setRate.setShortcut(QKeySequence('CTRL+R'))        
        setRate.triggered.connect(self.setPlaybackRate)    
        self.addAction(setRate)     
        
        rew = QAction(self)
        rew.setShortcut(Qt.Key_Left)        
        rew.triggered.connect(self.rew)    
        self.addAction(rew)   
        ff = QAction(self)
        ff.setShortcut(Qt.Key_Right)        
        ff.triggered.connect(self.ff)    
        self.addAction(ff)     
        rew5 = QAction(self)
        rew5.setShortcut(QKeySequence('CTRL+Left'))        
        rew5.triggered.connect(self.rew5)    
        self.addAction(rew5)   
        ff5 = QAction(self)
        ff5.setShortcut(QKeySequence('CTRL+Right'))        
        ff5.triggered.connect(self.ff5)    
        self.addAction(ff5)           
        
        # Edit tab
        self.graphicsView.scene.loadSignal.connect(self.propertyView.loadItem)  
        self.graphicsView.scene.saveSignal.connect(self.propertyView.saveItem)          
        self.graphicsView.scene.updateVideoSignal.connect(self.updateVideo)          
        self.graphicsView.scene.addItemListSignal.connect(self.items.addItem)  
        self.graphicsView.scene.removeItemListSignal.connect(self.items.removeItem)  
        self.graphicsView.scene.updateItemListSignal.connect(self.items.updateItem)  
        self.graphicsView.scene.changeCurrentItemSignal.connect(self.changeCurrentItem)  
        self.items.itemClicked.connect(self.checkItem)
        self.items.currentItemChanged.connect(self.currentItemChanged)
        self.items.deleteKeyPressed.connect(self.deleteItem)
        self.checkAll.clicked.connect(self.checkAllItems)
        self.seekSlider.sliderMoved.connect(self.setPosition)
        self.playButton.clicked.connect(self.playClicked)
        self.timer.timeout.connect(self.updateUI)
        self.connect( self.tabWidget, SIGNAL("currentChanged(int)"), self.tabChanged)
        
        
        # Search tab
        self.searchButton.clicked.connect(self.searchClicked)
        self.exportVideo.clicked.connect(self.exportVideoClicked)
        self.exportData.clicked.connect(self.exportDataClicked)
        self.searchCancel.clicked.connect(self.cancelClicked)        
        self.exportCancel.clicked.connect(self.cancelClicked)
        self.connect( self, SIGNAL("updateProgress"), self.updateProgress)       
        self.connect( self, SIGNAL("completeProgress"), self.guiMode)       
        self.guiMode(self.GUI_NORMAL)
        self.tabChanged(self.tabWidget.currentIndex())

        # Visualize tab
        self.visButton.clicked.connect(self.visClicked)
    def setPlaybackRate(self):
        rate, ok= QInputDialog.getDouble(self, 'Input Dialog', 'Enter playback rate:', 1.0,  0.1, 100)        
        if ok: 
            self.mediaPlayer.set_rate(rate)

    def rew(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() - 1000)            
        self.updateUI()

    def ff(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() + 1000)            
        self.updateUI()
        
    def rew5(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() - 5000)            
        self.updateUI()

    def ff5(self):
        self.mediaPlayer.set_time(self.mediaPlayer.get_time() + 5000)            
        self.updateUI()        
        
    def videoOpen(self):
        """Open a media file in a mediaPlayer"""
        filename = QFileDialog.getOpenFileName(self, "Open File", os.getcwdu())
        if not filename:
            return
        filename =  'file:///'+filename            
        dummy,  self.graphicsView.scene.videoname = os.path.split(unicode(filename))
        self.Media = self.Instance.media_new(unicode(filename))
        self.mediaPlayer.set_media(self.Media)
        self.Media.parse()
        self.setWindowTitle(self.Media.get_meta(0))
        if sys.platform == "linux2": # for Linux using the X Server
            self.mediaPlayer.set_xwindow(self.videoPlayer.winId())
        elif sys.platform == "win32": # for Windows
            self.mediaPlayer.set_hwnd(self.videoPlayer.winId())
        elif sys.platform == "darwin": # for MacOS
            self.mediaPlayer.set_agl(self.videoPlayer.windId())
        self.playClicked()

    def fileOpen(self):
        filename = QFileDialog.getOpenFileName(self, "Open File", os.getcwdu())
        if not filename:
            return
        self.graphicsView.scene.filename = filename
        file = QFile(self.graphicsView.scene.filename)
        file.open(QIODevice.ReadOnly)
        self.graphicsView.scene.clear()
        self.items.clearContents()
        self.items.setRowCount(0)
        s = QDataStream(file)
        buildNumber = s.readInt()        
        if (self.BUILD_NUMBER != buildNumber):
            QMessageBox.warning(self,  "Warning!",  "The data file is in format for build " + str(buildNumber) + ' \nCurrent software build is '+str(self.BUILD_NUMBER))
            return
        nItems = s.readInt()
        for i in range(nItems):
            cItem = s.readQString()
            item = eval(str(cItem)+'()') # create an item instance of appropriate type
            item.read(s)
            self.graphicsView.scene.addItem(item)
        self.actions[0].trigger()
        self.graphicsView.scene.update()

    def fileNew(self):
        self.graphicsView.scene.filename = None
        self.graphicsView.scene.clear()
        self.items.clearContents()
        self.items.setRowCount(0)
        self.actions[0].trigger()
        self.graphicsView.scene.update()
        

    def fileMerge(self):
        filename = QFileDialog.getOpenFileName(self, "Open File to Merge", os.getcwdu())
        if not filename:
            return
        if not self.graphicsView.scene.filename:
           self.graphicsView.scene.filename = filename
        file = QFile(filename)
        file.open(QIODevice.ReadOnly)
        s = QDataStream(file)
        buildNumber = s.readInt()        
        if (self.BUILD_NUMBER != buildNumber):
            QMessageBox.warning(self,  "Warning!",  "The data file is in format for build " + str(buildNumber) + ' \nCurrent software build is '+str(self.BUILD_NUMBER))
            return        
        nItems = s.readInt()
        for i in range(nItems):
            cItem = s.readQString()
            item = eval(str(cItem)+'()') # create an item instance of appropriate type
            item.read(s)
            # add Paths only
            if type(item) == Path:
                self.graphicsView.scene.addItem(item)
        self.graphicsView.scene.update()
        
    def fileSave(self):
        import shutil, datetime
        if not self.graphicsView.scene.filename: # run "save as" if no file name
            filename = QFileDialog.getSaveFileName(self, "Save File As", os.getcwdu())
            if not filename:
                return     
            self.graphicsView.scene.filename = filename                
        elif os.path.exists(self.graphicsView.scene.filename): # create a backup
            path,  name = os.path.split(unicode(self.graphicsView.scene.filename))
            shutil.move(self.graphicsView.scene.filename, os.path.join(path, datetime.datetime.today().strftime("%Y%m%d%H%M%S")+'.backup') )  
        file = QFile(self.graphicsView.scene.filename)
        file.open(QIODevice.WriteOnly)
        s = QDataStream(file)
        s.writeInt(self.BUILD_NUMBER)
        s.writeInt(len(self.graphicsView.scene.items()))
        for i in self.graphicsView.scene.items():
            s.writeQString(i.__class__.__name__)
            i.write(s)
            
    def fileSaveAs(self):
        filename = QFileDialog.getSaveFileName(self, "Save File As", os.getcwdu())
        if not filename:
            return     
        self.graphicsView.scene.filename = filename                
        self.fileSave()
            

    def stop(self):
        """Stop player"""
        self.mediaPlayer.stop()
        self.playButton.setIcon(QIcon('icons/player_play.png'))
        
    def setPosition(self, Position):
        """Set the position"""
        self.mediaPlayer.set_position(Position / 1000.0)

    def updateVideo(self, item):
        """Set the position based on the time on Path node"""
        if item.indP == None or item.startTime[item.indP] == None: 
            return
        time = QTime().msecsTo(item.startTime[item.indP].toTime())
        self.mediaPlayer.set_time(time)
        self.updateUI()
        
    def updateUI(self):
        """updates the user interface"""
        self.seekSlider.setValue(self.mediaPlayer.get_position() * 1000)

        if not self.mediaPlayer.is_playing():
            self.timer.stop()
            if not self.isPaused:
                self.stop()
        
        time = self.mediaPlayer.get_time()
        if time != -1:
            self.graphicsView.time = QTime().addMSecs(time)
            self.status.setText(self.graphicsView.time.toString('hh:mm:ss'))
        else:
            self.status.setText(QTime().toString('hh:mm:ss'))
            
    def deleteItem(self):
        if self.items.currentItem():
            self.graphicsView.scene.undoStack.push(RemoveCommand(self.graphicsView.scene, self.items.currentItem().g))                                        
        
    def updateGItems(self):
        for n in range(self.items.rowCount()):
            if self.items.item(n, 0).checkState() == Qt.Checked:
                self.items.item(n, 0).g.setVisible(True)
            else:
                self.items.item(n, 0).g.setVisible(False)
                
                
    def checkItem(self, item):
        if item.checkState() == Qt.Checked:
            item.g.setVisible(True)
        else:
            item.g.setVisible(False)

    def changeCurrentItem(self):        
        #  choose current item
        for n in range(self.items.rowCount()):
            i = self.items.item(n, 0)
            if self.graphicsView.scene.currentPath == i.g:
                self.items.setCurrentItem(i)
#                print 'changeCurrentItem to '+i.g.id.toString()
                
    def currentItemChanged(self, current, previous):
        self.graphicsView.scene.clearSelection()
        if current:
            current.g.setSelected(True)
            self.graphicsView.scene.currentPath = current.g
            self.graphicsView.scene.loadSignal.emit(self.graphicsView.scene.currentPath)            
        
    def checkAllItems(self):
        nItems = self.items.rowCount()
        if nItems == 0:
            return
        if self.items.item(0, 0).checkState() == Qt.Unchecked:
            for n in range(nItems):
                self.items.item(n, 0).setCheckState(Qt.Checked)
        else: 
            for n in range(nItems):
                self.items.item(n, 0).setCheckState(Qt.Unchecked)
        self.updateGItems()

    def showUndoHistory(self):
        self.undoView.show()
        self.undoView.adjustSize()
        self.undoView.setAttribute(Qt.WA_QuitOnClose, False)
       
    def about(self):
        QMessageBox.about(self,  'About',  \
            '<p>Copyright: Alex Leykin @ CIL'+\
            '<p>Email: cil@indiana.edu'+\
            '<p><a href="http://indiana.edu/~cil">http://indiana.edu/~cil</a>'+
            '<p>Build number '+str(self.BUILD_NUMBER))

    def initHelp(self):
        from PyQt4 import QtHelp
        from PyQt4.QtWebKit import QWebView
        import helpbrowser
        self.help = QtHelp.QHelpEngine('help/help.qhc',  self)
        ok = self.help.setupData()

        self.helpWindow = QDialog(self, Qt.Window)            
        self.helpWindow.setWindowTitle('Video Annotation Help')
        helpBrowser = helpbrowser.HelpBrowser(self.help)
        helpPanel = QSplitter(Qt.Vertical)
        helpPanel.addWidget(self.help.contentWidget() )
        helpPanel.addWidget(helpBrowser)
        helpPanel.setStretchFactor(1, 4)
        self.helpWindow.setLayout(QVBoxLayout())
        self.helpWindow.layout().addWidget(helpPanel)
        self.helpWindow.setMinimumSize(640, 700)
        self.help.contentWidget().linkActivated.connect(helpBrowser.load)
        
def main():
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    sys.exit(app.exec_())
  
if __name__ == "__main__":
    main()
    










    





